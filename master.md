# ğŸ›¡ï¸ TAKARA MASTER PROMPT (v6) â€” CRITICAL SECURITY & ARCHITECTURE FIX

**Role:** Senior Blockchain Architect & Security Lead  
**Priority:** CRITICAL  
**Project:** TAKARA (ex-TUSD)  
**Repository:** https://github.com/olegin77/TUSD  
**Production:** https://143.198.17.162/vaults

---

## ğŸ“‹ EXECUTIVE SUMMARY

Ğ­Ñ‚Ğ¾Ñ‚ Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚ ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ¸Ñ‚ **Ñ„Ğ¸Ğ½Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ¸ Ğ¾Ğ±ÑĞ·Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğµ** Ğ¸ÑĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğ° TAKARA. Ğ’ÑĞµ Ğ¿Ñ€ĞµĞ´Ñ‹Ğ´ÑƒÑ‰Ğ¸Ğµ Ğ²ĞµÑ€ÑĞ¸Ğ¸ Ğ¢Ğ— (v4, v5) Ğ¾Ñ‚Ğ¼ĞµĞ½ÑÑÑ‚ÑÑ Ğ² Ñ‡Ğ°ÑÑ‚Ğ¸ Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ²Ğ¾Ñ€ĞµÑ‡Ğ¸Ğ¹ Ñ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¼ Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ¾Ğ¼.

### ĞšÑ€Ğ¸Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ Ğ¿Ñ€Ğ¾Ğ±Ğ»ĞµĞ¼Ñ‹ Ğ´Ğ»Ñ Ğ¸ÑĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ:

1. **âŒ ĞĞµĞ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ñ‹Ğµ APY** â€” Vault 2 Ğ¸ Vault 3 Ğ¸Ğ¼ĞµÑÑ‚ Ğ½ĞµĞ²ĞµÑ€Ğ½Ñ‹Ğµ ÑÑ‚Ğ°Ñ€Ñ‚Ğ¾Ğ²Ñ‹Ğµ Ğ¿Ñ€Ğ¾Ñ†ĞµĞ½Ñ‚Ñ‹
2. **âŒ ĞÑ‚ÑÑƒÑ‚ÑÑ‚Ğ²ÑƒĞµÑ‚ Ğ¼ÑƒĞ»ÑŒÑ‚Ğ¸-Ñ‡ĞµĞ¹Ğ½ Ğ´ĞµĞ¿Ğ¾Ğ·Ğ¸Ñ‚** â€” Ğ½ĞµÑ‚ Ğ»Ğ¾Ğ³Ğ¸ĞºĞ¸ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ¿Ğ¾Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ñ USDT (Tron) + Takara/Laika (Solana)
3. **âŒ Wexel Ğ½Ğµ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ¾Ğ²Ğ°Ğ½ ĞºĞ°Ğº NFT** â€” Ğ²ĞµĞºÑĞµĞ»ÑŒ Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ±Ñ‹Ñ‚ÑŒ Solana NFT, Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´Ğ°ÑÑ‰Ğ¸Ğ¼ Ğ¿Ñ€Ğ°Ğ²Ğ¾ ÑĞ¾Ğ±ÑÑ‚Ğ²ĞµĞ½Ğ½Ğ¾ÑÑ‚Ğ¸
4. **âŒ ĞĞµÑ‚ Ğ²ĞµÑ€Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ğ¸ Ğ²Ğ»Ğ°Ğ´ĞµĞ½Ğ¸Ñ** â€” Ğ¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ğ²ÑƒĞµÑ‚ ĞºÑ€Ğ¸Ğ¿Ñ‚Ğ¾Ğ³Ñ€Ğ°Ñ„Ğ¸Ñ‡ĞµÑĞºĞ°Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¿Ñ€Ğ°Ğ²Ğ° Ğ½Ğ° claim rewards
5. **âŒ Ğ£ÑĞ·Ğ²Ğ¸Ğ¼Ğ¾ÑÑ‚Ğ¸ Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ÑÑ‚Ğ¸** â€” Ğ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ° Ğ¿Ğ¾Ğ´Ğ´ĞµĞ»ĞºĞ° Ğ²ĞµĞºÑĞµĞ»Ñ, Ğ½ĞµÑ‚ Ğ·Ğ°Ñ‰Ğ¸Ñ‚Ñ‹ Ğ¾Ñ‚ replay-Ğ°Ñ‚Ğ°Ğº

---

## ğŸ”¢ Ğ§ĞĞ¡Ğ¢Ğ¬ 1: Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ˜Ğ• Ğ­ĞšĞĞĞĞœĞ˜ĞšĞ˜ (APY CORRECTION)

### âš ï¸ Ğ’ĞĞ–ĞĞ: Ğ­Ñ‚Ğ¸ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ ÑĞ²Ğ»ÑÑÑ‚ÑÑ Ğ¤Ğ˜ĞĞĞ›Ğ¬ĞĞ«ĞœĞ˜ Ğ¸ Ğ´Ğ¾Ğ»Ğ¶Ğ½Ñ‹ Ğ±Ñ‹Ñ‚ÑŒ Ğ¿Ñ€Ğ¸Ğ¼ĞµĞ½ĞµĞ½Ñ‹ Ğ²ĞµĞ·Ğ´Ğµ: Ğ‘Ğ”, Ğ±ÑĞºĞµĞ½Ğ´, Ñ„Ñ€Ğ¾Ğ½Ñ‚ĞµĞ½Ğ´, ÑĞ¼Ğ°Ñ€Ñ‚-ĞºĞ¾Ğ½Ñ‚Ñ€Ğ°ĞºÑ‚Ñ‹.

---

### ğŸŸ¢ Vault 1: "Starter" (Laika Boost) â€” Ğ‘Ğ•Ğ— Ğ˜Ğ—ĞœĞ•ĞĞ•ĞĞ˜Ğ™

| ĞŸĞ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€              | Ğ—Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ                                           |
| --------------------- | -------------------------------------------------- |
| Ğ¡Ñ€Ğ¾Ğº                  | 12 Ğ¼ĞµÑÑÑ†ĞµĞ²                                         |
| ĞœĞ¸Ğ½. Ğ²Ñ…Ğ¾Ğ´             | $100 USDT (TRC20)                                  |
| Start APY (Ğ±ĞµĞ· Ğ±ÑƒÑÑ‚Ğ°) | Ğ Ğ°ÑÑÑ‡Ğ¸Ñ‚Ğ°Ñ‚ÑŒ Ñ‚Ğ°Ğº, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ MAX = 8.40%                  |
| Max APY (Ñ Ğ±ÑƒÑÑ‚Ğ¾Ğ¼)    | **8.40%**                                          |
| Boost Token           | Laika (Solana SPL)                                 |
| Boost Ğ£ÑĞ»Ğ¾Ğ²Ğ¸Ğµ         | Ğ¥Ğ¾Ğ»Ğ´ Laika Ğ½Ğ° 40% Ğ¾Ñ‚ Ğ´ĞµĞ¿Ğ¾Ğ·Ğ¸Ñ‚Ğ°                      |
| ĞÑ†ĞµĞ½ĞºĞ° Laika          | Ğ Ñ‹Ğ½Ğ¾Ñ‡Ğ½Ğ°Ñ Ñ†ĞµĞ½Ğ° (CoinGecko) **Ğ¼Ğ¸Ğ½ÑƒÑ 15% Ğ´Ğ¸ÑĞºĞ¾Ğ½Ñ‚**    |
| Takara Mining         | 30% APR (Ğ½Ğ°Ñ‡Ğ¸ÑĞ»ĞµĞ½Ğ¸Ğµ ĞµĞ¶ĞµĞ´Ğ½ĞµĞ²Ğ½Ğ¾, claim Ñ€Ğ°Ğ· Ğ² Ğ½ĞµĞ´ĞµĞ»Ñ) |

---

### ğŸŸ¡ Vault 2: "Advanced" (Takara Boost) â€” Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ˜Ğ¢Ğ¬!

| ĞŸĞ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€                  | Ğ¡Ñ‚Ğ°Ñ€Ğ¾Ğµ (Ğ½ĞµĞ²ĞµÑ€Ğ½Ğ¾Ğµ)   | ĞĞ¾Ğ²Ğ¾Ğµ (Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾Ğµ)        |
| ------------------------- | ------------------- | ------------------------- |
| Ğ¡Ñ€Ğ¾Ğº                      | 30 Ğ¼ĞµÑÑÑ†ĞµĞ²          | **30 Ğ¼ĞµÑÑÑ†ĞµĞ²** âœ“          |
| ĞœĞ¸Ğ½. Ğ²Ñ…Ğ¾Ğ´                 | $1,500              | **$1,500** âœ“              |
| **Start APY (Ğ±ĞµĞ· Ğ±ÑƒÑÑ‚Ğ°)** | âŒ 4%               | âœ… **7%**                 |
| **Takara Boost**          | âŒ Ğ½ĞµĞ²ĞµÑ€Ğ½Ğ¾          | âœ… **+6%**                |
| **Max APY (Ñ Ğ±ÑƒÑÑ‚Ğ¾Ğ¼)**    | âŒ 8%               | âœ… **13%**                |
| Boost Token               | Takara (Solana SPL) | **Takara (Solana SPL)** âœ“ |
| Boost Ğ£ÑĞ»Ğ¾Ğ²Ğ¸Ğµ             | 1:1 Ğº Ğ´ĞµĞ¿Ğ¾Ğ·Ğ¸Ñ‚Ñƒ      | **1:1 Ğº Ğ´ĞµĞ¿Ğ¾Ğ·Ğ¸Ñ‚Ñƒ** âœ“      |
| ĞÑ†ĞµĞ½ĞºĞ° Takara             | Ğ¤Ğ¸ĞºÑ $0.10          | **Ğ¤Ğ¸ĞºÑ $0.10** âœ“          |
| Takara Mining             | 30% APR             | **30% APR** âœ“             |

**ĞœĞ½Ğ¾Ğ¶Ğ¸Ñ‚ĞµĞ»Ğ¸ Ñ‡Ğ°ÑÑ‚Ğ¾Ñ‚Ñ‹ Ğ²Ñ‹Ğ¿Ğ»Ğ°Ñ‚ (Ğ¿Ñ€Ğ¸Ğ¼ĞµĞ½ÑÑÑ‚ÑÑ Ğº APY):**

- Monthly: x1.0
- Quarterly: x1.15
- Yearly: x1.30

**ĞŸÑ€Ğ¸Ğ¼ĞµÑ€ Ñ€Ğ°ÑÑ‡Ñ‘Ñ‚Ğ° Max APY Ñ Yearly:**

- Base: 7% + Boost: 6% = 13%
- Ğ¡ Ğ¼Ğ½Ğ¾Ğ¶Ğ¸Ñ‚ĞµĞ»ĞµĞ¼ Yearly: 13% Ã— 1.30 = **16.9%**

---

### ğŸ”´ Vault 3: "Whale" (Takara Boost) â€” Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ˜Ğ¢Ğ¬!

| ĞŸĞ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€                  | Ğ¡Ñ‚Ğ°Ñ€Ğ¾Ğµ (Ğ½ĞµĞ²ĞµÑ€Ğ½Ğ¾Ğµ)   | ĞĞ¾Ğ²Ğ¾Ğµ (Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾Ğµ)        |
| ------------------------- | ------------------- | ------------------------- |
| Ğ¡Ñ€Ğ¾Ğº                      | 36 Ğ¼ĞµÑÑÑ†ĞµĞ²          | **36 Ğ¼ĞµÑÑÑ†ĞµĞ²** âœ“          |
| ĞœĞ¸Ğ½. Ğ²Ñ…Ğ¾Ğ´                 | $5,000              | **$5,000** âœ“              |
| **Start APY (Ğ±ĞµĞ· Ğ±ÑƒÑÑ‚Ğ°)** | âŒ 6%               | âœ… **8%**                 |
| **Takara Boost**          | âŒ Ğ½ĞµĞ²ĞµÑ€Ğ½Ğ¾          | âœ… **+7%**                |
| **Max APY (Ñ Ğ±ÑƒÑÑ‚Ğ¾Ğ¼)**    | âŒ 10%              | âœ… **15%**                |
| Boost Token               | Takara (Solana SPL) | **Takara (Solana SPL)** âœ“ |
| Boost Ğ£ÑĞ»Ğ¾Ğ²Ğ¸Ğµ             | 1:1 Ğº Ğ´ĞµĞ¿Ğ¾Ğ·Ğ¸Ñ‚Ñƒ      | **1:1 Ğº Ğ´ĞµĞ¿Ğ¾Ğ·Ğ¸Ñ‚Ñƒ** âœ“      |
| ĞÑ†ĞµĞ½ĞºĞ° Takara             | Ğ¤Ğ¸ĞºÑ $0.10          | **Ğ¤Ğ¸ĞºÑ $0.10** âœ“          |
| Takara Mining             | 40% APR             | **40% APR** âœ“             |

**ĞœĞ½Ğ¾Ğ¶Ğ¸Ñ‚ĞµĞ»Ğ¸ Ñ‡Ğ°ÑÑ‚Ğ¾Ñ‚Ñ‹ Ğ²Ñ‹Ğ¿Ğ»Ğ°Ñ‚:**

- Monthly: x1.0
- Quarterly: x1.15
- Yearly: x1.30

**ĞŸÑ€Ğ¸Ğ¼ĞµÑ€ Ñ€Ğ°ÑÑ‡Ñ‘Ñ‚Ğ° Max APY Ñ Yearly:**

- Base: 8% + Boost: 7% = 15%
- Ğ¡ Ğ¼Ğ½Ğ¾Ğ¶Ğ¸Ñ‚ĞµĞ»ĞµĞ¼ Yearly: 15% Ã— 1.30 = **19.5%**

---

## ğŸ” Ğ§ĞĞ¡Ğ¢Ğ¬ 2: ĞĞ Ğ¥Ğ˜Ğ¢Ğ•ĞšĞ¢Ğ£Ğ Ğ WEXEL (NFT-Ğ’Ğ•ĞšĞ¡Ğ•Ğ›Ğ¬)

### 2.1 ĞšĞ¾Ğ½Ñ†ĞµĞ¿Ñ†Ğ¸Ñ

**Wexel (Ğ’ĞµĞºÑĞµĞ»ÑŒ)** â€” ÑÑ‚Ğ¾ Solana NFT (Metaplex Core Standard), ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğ¹ ÑĞ²Ğ»ÑĞµÑ‚ÑÑ **Ğ•Ğ”Ğ˜ĞĞ¡Ğ¢Ğ’Ğ•ĞĞĞ«Ğœ** Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸ĞµĞ¼ Ğ¿Ñ€Ğ°Ğ²Ğ° ÑĞ¾Ğ±ÑÑ‚Ğ²ĞµĞ½Ğ½Ğ¾ÑÑ‚Ğ¸ Ğ½Ğ° Ğ´ĞµĞ¿Ğ¾Ğ·Ğ¸Ñ‚.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      WEXEL NFT                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Token Standard: Metaplex Core (Ğ¸Ğ»Ğ¸ Token-2022)       â”‚  â”‚
â”‚  â”‚  Mint Authority: TAKARA Program (PDA)                 â”‚  â”‚
â”‚  â”‚  Update Authority: TAKARA Program (PDA)               â”‚  â”‚
â”‚  â”‚  Transferable: YES (Ğ²Ñ‚Ğ¾Ñ€Ğ¸Ñ‡Ğ½Ñ‹Ğ¹ Ñ€Ñ‹Ğ½Ğ¾Ğº)                  â”‚  â”‚
â”‚  â”‚  Burnable: YES (Ğ¿Ñ€Ğ¸ Ğ¿Ğ¾Ğ³Ğ°ÑˆĞµĞ½Ğ¸Ğ¸ Ğ´ĞµĞ¿Ğ¾Ğ·Ğ¸Ñ‚Ğ°)               â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                             â”‚
â”‚  ON-CHAIN METADATA (immutable):                             â”‚
â”‚  â”œâ”€â”€ deposit_id: u64                                        â”‚
â”‚  â”œâ”€â”€ vault_type: u8 (1, 2, or 3)                           â”‚
â”‚  â”œâ”€â”€ deposit_amount_usdt: u64 (lamports precision)         â”‚
â”‚  â”œâ”€â”€ deposit_currency: "USDT_TRC20"                        â”‚
â”‚  â”œâ”€â”€ tron_tx_hash: String (32 bytes hex)                   â”‚
â”‚  â”œâ”€â”€ base_apy: u16 (basis points, e.g., 700 = 7%)          â”‚
â”‚  â”œâ”€â”€ boost_apy: u16 (basis points)                         â”‚
â”‚  â”œâ”€â”€ total_apy: u16 (basis points)                         â”‚
â”‚  â”œâ”€â”€ lock_period_months: u8                                â”‚
â”‚  â”œâ”€â”€ lock_start_timestamp: i64                             â”‚
â”‚  â”œâ”€â”€ lock_end_timestamp: i64                               â”‚
â”‚  â”œâ”€â”€ payout_frequency: u8 (1=monthly, 3=quarterly, 12=yr)  â”‚
â”‚  â”œâ”€â”€ boost_token_mint: Pubkey (Laika or Takara)            â”‚
â”‚  â”œâ”€â”€ boost_token_amount: u64                               â”‚
â”‚  â”œâ”€â”€ boost_token_locked: bool                              â”‚
â”‚  â””â”€â”€ created_at: i64                                       â”‚
â”‚                                                             â”‚
â”‚  MUTABLE STATE (PDA Account):                               â”‚
â”‚  â”œâ”€â”€ total_claimed_usdt: u64                               â”‚
â”‚  â”œâ”€â”€ total_claimed_takara: u64                             â”‚
â”‚  â”œâ”€â”€ last_claim_timestamp: i64                             â”‚
â”‚  â””â”€â”€ is_redeemed: bool                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 ĞŸÑ€Ğ°Ğ²Ğ¸Ğ»Ğ° Ğ²Ğ»Ğ°Ğ´ĞµĞ½Ğ¸Ñ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    OWNERSHIP RULES                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  RULE 1: NFT Owner = Deposit Owner                             â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”‚  ĞšĞ¾ÑˆĞµĞ»Ñ‘Ğº, Ğ½Ğ° ĞºĞ¾Ñ‚Ğ¾Ñ€Ğ¾Ğ¼ Ğ½Ğ°Ñ…Ğ¾Ğ´Ğ¸Ñ‚ÑÑ Wexel NFT, ÑĞ²Ğ»ÑĞµÑ‚ÑÑ             â”‚
â”‚  Ğ•Ğ”Ğ˜ĞĞ¡Ğ¢Ğ’Ğ•ĞĞĞ«Ğœ Ğ²Ğ»Ğ°Ğ´ĞµĞ»ÑŒÑ†ĞµĞ¼ Ğ´ĞµĞ¿Ğ¾Ğ·Ğ¸Ñ‚Ğ° Ğ¸ Ğ¸Ğ¼ĞµĞµÑ‚ Ğ¿Ñ€Ğ°Ğ²Ğ¾:               â”‚
â”‚  â€¢ ĞšĞ»ĞµĞ¹Ğ¼Ğ¸Ñ‚ÑŒ USDT rewards                                       â”‚
â”‚  â€¢ ĞšĞ»ĞµĞ¹Ğ¼Ğ¸Ñ‚ÑŒ Takara mining rewards                              â”‚
â”‚  â€¢ ĞŸĞ¾Ğ³Ğ°ÑĞ¸Ñ‚ÑŒ Ğ´ĞµĞ¿Ğ¾Ğ·Ğ¸Ñ‚ (burn NFT â†’ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ principal)            â”‚
â”‚                                                                 â”‚
â”‚  RULE 2: Transfer = Transfer of Rights                         â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”‚  ĞŸÑ€Ğ¸ Ğ¿Ñ€Ğ¾Ğ´Ğ°Ğ¶Ğµ/Ğ¿ĞµÑ€ĞµĞ´Ğ°Ñ‡Ğµ NFT Ğ½Ğ° Ğ²Ñ‚Ğ¾Ñ€Ğ¸Ñ‡Ğ½Ğ¾Ğ¼ Ñ€Ñ‹Ğ½ĞºĞµ:                  â”‚
â”‚  â€¢ Ğ¡Ñ‚Ğ°Ñ€Ñ‹Ğ¹ Ğ²Ğ»Ğ°Ğ´ĞµĞ»ĞµÑ† Ğ¢Ğ•Ğ Ğ¯Ğ•Ğ¢ Ğ²ÑĞµ Ğ¿Ñ€Ğ°Ğ²Ğ°                            â”‚
â”‚  â€¢ ĞĞ¾Ğ²Ñ‹Ğ¹ Ğ²Ğ»Ğ°Ğ´ĞµĞ»ĞµÑ† ĞŸĞĞ›Ğ£Ğ§ĞĞ•Ğ¢ Ğ²ÑĞµ Ğ¿Ñ€Ğ°Ğ²Ğ° Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸             â”‚
â”‚  â€¢ Backend Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ¾Ñ‚ÑĞ»ĞµĞ¶Ğ¸Ğ²Ğ°Ñ‚ÑŒ transfers Ğ¸ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ÑÑ‚ÑŒ owner      â”‚
â”‚                                                                 â”‚
â”‚  RULE 3: No NFT = No Rights                                    â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”‚  Ğ‘ĞµĞ· NFT Ğ² ĞºĞ¾ÑˆĞµĞ»ÑŒĞºĞµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ ĞĞ• ĞœĞĞ–Ğ•Ğ¢:                     â”‚
â”‚  â€¢ Ğ’Ğ¸Ğ´ĞµÑ‚ÑŒ Ğ´ĞµĞ¿Ğ¾Ğ·Ğ¸Ñ‚ Ğ² Dashboard                                  â”‚
â”‚  â€¢ ĞšĞ»ĞµĞ¹Ğ¼Ğ¸Ñ‚ÑŒ Ğ»ÑĞ±Ñ‹Ğµ Ğ½Ğ°Ğ³Ñ€Ğ°Ğ´Ñ‹                                      â”‚
â”‚  â€¢ ĞŸĞ¾Ğ³Ğ°ÑĞ¸Ñ‚ÑŒ Ğ´ĞµĞ¿Ğ¾Ğ·Ğ¸Ñ‚                                            â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.3 Ğ‘ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ÑÑ‚ÑŒ Wexel

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  SECURITY REQUIREMENTS                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  ğŸ›¡ï¸ ANTI-FORGERY (Ğ—Ğ°Ñ‰Ğ¸Ñ‚Ğ° Ğ¾Ñ‚ Ğ¿Ğ¾Ğ´Ğ´ĞµĞ»ĞºĞ¸)                          â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”‚  1. Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ TAKARA Program Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ¼Ğ¸Ğ½Ñ‚Ğ¸Ñ‚ÑŒ Wexel NFT              â”‚
â”‚  2. Mint Authority = Program PDA (Ğ½Ğµ EOA ĞºĞ¾ÑˆĞµĞ»Ñ‘Ğº!)             â”‚
â”‚  3. Collection NFT Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑĞ°Ğ½ Program Authority                  â”‚
â”‚  4. Backend Ğ²ĞµÑ€Ğ¸Ñ„Ğ¸Ñ†Ğ¸Ñ€ÑƒĞµÑ‚: Collection Address + Creator         â”‚
â”‚                                                                 â”‚
â”‚  ğŸ”’ CLAIM VERIFICATION (Ğ’ĞµÑ€Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ ĞºĞ»ĞµĞ¹Ğ¼Ğ°)                    â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”‚  ON-CHAIN (Smart Contract):                                    â”‚
â”‚  â€¢ ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ: signer == token_account.owner                    â”‚
â”‚  â€¢ ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ: nft.collection == TAKARA_COLLECTION              â”‚
â”‚  â€¢ ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ: nft.creators[0].verified == true                 â”‚
â”‚  â€¢ ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ: wexel_state.is_redeemed == false                 â”‚
â”‚                                                                 â”‚
â”‚  OFF-CHAIN (Backend):                                          â”‚
â”‚  â€¢ Ğ’ĞµÑ€Ğ¸Ñ„Ğ¸Ñ†Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑÑŒ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ Ğ²Ğ»Ğ°Ğ´ĞµĞ»ÑŒÑ†ĞµĞ¼ NFT             â”‚
â”‚  â€¢ ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ ownership Ñ‡ĞµÑ€ĞµĞ· RPC getTokenAccountsByOwner       â”‚
â”‚  â€¢ Cross-check Ñ Ğ‘Ğ” (deposit_id, amounts, timestamps)          â”‚
â”‚                                                                 â”‚
â”‚  ğŸš« REPLAY ATTACK PROTECTION                                   â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”‚  â€¢ ĞšĞ°Ğ¶Ğ´Ñ‹Ğ¹ claim Ğ²ĞºĞ»ÑÑ‡Ğ°ĞµÑ‚ nonce (Ğ¸Ğ½ĞºÑ€ĞµĞ¼ĞµĞ½Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼Ñ‹Ğ¹ ÑÑ‡Ñ‘Ñ‚Ñ‡Ğ¸Ğº)      â”‚
â”‚  â€¢ Timestamp validation (Ğ½Ğµ ÑÑ‚Ğ°Ñ€ÑˆĞµ 5 Ğ¼Ğ¸Ğ½ÑƒÑ‚)                    â”‚
â”‚  â€¢ Unique message per claim: `claim:${wexel_id}:${nonce}:${ts}`â”‚
â”‚                                                                 â”‚
â”‚  ğŸ”¥ BURN ON REDEEM                                             â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”‚  ĞŸÑ€Ğ¸ Ğ¿Ğ¾Ğ³Ğ°ÑˆĞµĞ½Ğ¸Ğ¸ Ğ´ĞµĞ¿Ğ¾Ğ·Ğ¸Ñ‚Ğ°:                                       â”‚
â”‚  â€¢ NFT ÑĞ¶Ğ¸Ğ³Ğ°ĞµÑ‚ÑÑ (burn)                                        â”‚
â”‚  â€¢ Boost Ñ‚Ğ¾ĞºĞµĞ½Ñ‹ Ñ€Ğ°Ğ·Ğ»Ğ¾Ñ‡Ğ¸Ğ²Ğ°ÑÑ‚ÑÑ Ğ¸ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ÑÑ‚ÑÑ Ğ²Ğ»Ğ°Ğ´ĞµĞ»ÑŒÑ†Ñƒ         â”‚
â”‚  â€¢ wexel_state.is_redeemed = true                              â”‚
â”‚  â€¢ Principal USDT Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµÑ‚ÑÑ Ğ½Ğ° Tron ĞºĞ¾ÑˆĞµĞ»Ñ‘Ğº Ğ²Ğ»Ğ°Ğ´ĞµĞ»ÑŒÑ†Ğ°       â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ”„ Ğ§ĞĞ¡Ğ¢Ğ¬ 3: ĞœĞ£Ğ›Ğ¬Ğ¢Ğ˜-Ğ§Ğ•Ğ™Ğ Ğ”Ğ•ĞŸĞĞ—Ğ˜Ğ¢ (TRON + SOLANA)

### 3.1 ĞÑ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ° Flow

````
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    MULTI-CHAIN DEPOSIT FLOW                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

User Wallets Required:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   TronLink   â”‚     â”‚   Phantom    â”‚
â”‚   (TRC20)    â”‚     â”‚   (Solana)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

                    STEP-BY-STEP FLOW
                    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ STEP 0: WALLET CONNECTION                                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                          â”‚
â”‚  Frontend Actions:                                                       â”‚
â”‚  1. ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ Ğ½Ğ°Ğ»Ğ¸Ñ‡Ğ¸Ğµ TronLink extension                                â”‚
â”‚  2. ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ Ğ½Ğ°Ğ»Ğ¸Ñ‡Ğ¸Ğµ Phantom/Solflare extension                        â”‚
â”‚  3. Ğ—Ğ°Ğ¿Ñ€Ğ¾ÑĞ¸Ñ‚ÑŒ Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ ĞĞ‘ĞĞ˜Ğ¥ ĞºĞ¾ÑˆĞµĞ»ÑŒĞºĞ¾Ğ²                               â”‚
â”‚  4. ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ¸ ÑĞ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ:                                               â”‚
â”‚     â€¢ tronAddress: string (base58)                                      â”‚
â”‚     â€¢ solanaAddress: PublicKey                                          â”‚
â”‚                                                                          â”‚
â”‚  Validation:                                                             â”‚
â”‚  â€¢ ĞĞ±Ğ° ĞºĞ¾ÑˆĞµĞ»ÑŒĞºĞ° ĞĞ‘Ğ¯Ğ—ĞĞ¢Ğ•Ğ›Ğ¬ĞĞ« Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½Ğ¸Ñ                             â”‚
â”‚  â€¢ ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ğ¾ÑˆĞ¸Ğ±ĞºÑƒ ĞµÑĞ»Ğ¸ Ğ¾Ğ´Ğ¸Ğ½ Ğ¸Ğ· ĞºĞ¾ÑˆĞµĞ»ÑŒĞºĞ¾Ğ² Ğ½Ğµ Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½                  â”‚
â”‚                                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                   â”‚
                                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ STEP 1: USDT DEPOSIT (TRON BLOCKCHAIN)                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                          â”‚
â”‚  User Action: ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ USDT TRC20 Ğ½Ğ° Treasury                          â”‚
â”‚                                                                          â”‚
â”‚  Frontend:                                                               â”‚
â”‚  1. ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ñ„Ğ¾Ñ€Ğ¼Ñƒ Ñ ÑÑƒĞ¼Ğ¼Ğ¾Ğ¹ Ğ´ĞµĞ¿Ğ¾Ğ·Ğ¸Ñ‚Ğ°                                    â”‚
â”‚  2. Ğ’Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ: amount >= vault.minEntry                                 â”‚
â”‚  3. Ğ’Ñ‹Ğ·Ğ²Ğ°Ñ‚ÑŒ TronLink:                                                   â”‚
â”‚     ```javascript                                                        â”‚
â”‚     const tronWeb = window.tronWeb;                                     â”‚
â”‚     const usdtContract = await tronWeb.contract().at(USDT_TRC20_ADDR);  â”‚
â”‚     const tx = await usdtContract.transfer(                             â”‚
â”‚       TAKARA_TREASURY_TRON,                                             â”‚
â”‚       amount * 1e6  // USDT has 6 decimals                              â”‚
â”‚     ).send();                                                           â”‚
â”‚     ```                                                                  â”‚
â”‚  4. Ğ–Ğ´Ğ°Ñ‚ÑŒ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ñ (â‰¥19 confirmations)                             â”‚
â”‚  5. Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ: tronTxHash                                               â”‚
â”‚                                                                          â”‚
â”‚  Backend Verification:                                                   â”‚
â”‚  1. ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ tronTxHash Ğ¾Ñ‚ Ñ„Ñ€Ğ¾Ğ½Ñ‚ĞµĞ½Ğ´Ğ°                                    â”‚
â”‚  2. Ğ—Ğ°Ğ¿Ñ€Ğ¾ÑĞ¸Ñ‚ÑŒ Tron RPC: getTransactionInfo(txHash)                      â”‚
â”‚  3. ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ:                                                          â”‚
â”‚     â€¢ tx.to == TAKARA_TREASURY_TRON                                     â”‚
â”‚     â€¢ tx.contractAddress == USDT_TRC20_ADDR                             â”‚
â”‚     â€¢ tx.amount >= minEntry                                             â”‚
â”‚     â€¢ tx.status == SUCCESS                                              â”‚
â”‚     â€¢ tx.confirmations >= 19                                            â”‚
â”‚  4. Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ pending deposit record Ğ² Ğ‘Ğ”                                 â”‚
â”‚                                                                          â”‚
â”‚  Status: PENDING_BOOST (ĞµÑĞ»Ğ¸ Ğ±ÑƒÑÑ‚ Ğ²Ñ‹Ğ±Ñ€Ğ°Ğ½) Ğ¸Ğ»Ğ¸ PENDING_MINT              â”‚
â”‚                                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                   â”‚
                                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ STEP 2: BOOST TOKEN LOCK (SOLANA BLOCKCHAIN) â€” OPTIONAL                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                          â”‚
â”‚  âš ï¸ Ğ­Ñ‚Ğ¾Ñ‚ ÑˆĞ°Ğ³ ĞŸĞ ĞĞŸĞ£Ğ¡ĞšĞĞ•Ğ¢Ğ¡Ğ¯ ĞµÑĞ»Ğ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ½Ğµ Ğ²Ñ‹Ğ±Ñ€Ğ°Ğ» Ğ±ÑƒÑÑ‚              â”‚
â”‚                                                                          â”‚
â”‚  User Action: Ğ—Ğ°Ğ»Ğ¾Ñ‡Ğ¸Ñ‚ÑŒ Laika Ğ¸Ğ»Ğ¸ Takara Ğ½Ğ° ÑĞ¼Ğ°Ñ€Ñ‚-ĞºĞ¾Ğ½Ñ‚Ñ€Ğ°ĞºÑ‚               â”‚
â”‚                                                                          â”‚
â”‚  Ğ Ğ°ÑÑ‡Ñ‘Ñ‚ Ñ‚Ñ€ĞµĞ±ÑƒĞµĞ¼Ğ¾Ğ¹ ÑÑƒĞ¼Ğ¼Ñ‹:                                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Vault 1 (Laika):                                                   â”‚ â”‚
â”‚  â”‚   requiredLaika = (depositUSDT * 0.40) / (laikaPrice * 0.85)      â”‚ â”‚
â”‚  â”‚   Ğ³Ğ´Ğµ laikaPrice = CoinGecko price, 0.85 = 15% discount           â”‚ â”‚
â”‚  â”‚                                                                    â”‚ â”‚
â”‚  â”‚ Vault 2 & 3 (Takara):                                             â”‚ â”‚
â”‚  â”‚   requiredTakara = depositUSDT / 0.10                             â”‚ â”‚
â”‚  â”‚   Ğ³Ğ´Ğµ 0.10 = Ñ„Ğ¸ĞºÑĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹ ĞºÑƒÑ€Ñ Takara                            â”‚ â”‚
â”‚  â”‚   ĞŸÑ€Ğ¸Ğ¼ĞµÑ€: $1500 Ğ´ĞµĞ¿Ğ¾Ğ·Ğ¸Ñ‚ â†’ 15,000 Takara tokens                    â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                          â”‚
â”‚  Frontend:                                                               â”‚
â”‚  1. ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ñ‚Ñ€ĞµĞ±ÑƒĞµĞ¼ÑƒÑ ÑÑƒĞ¼Ğ¼Ñƒ boost Ñ‚Ğ¾ĞºĞµĞ½Ğ¾Ğ²                              â”‚
â”‚  2. ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ Ğ±Ğ°Ğ»Ğ°Ğ½Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ                                       â”‚
â”‚  3. Ğ’Ñ‹Ğ·Ğ²Ğ°Ñ‚ÑŒ Solana Program:                                             â”‚
â”‚     ```typescript                                                        â”‚
â”‚     const tx = await program.methods                                    â”‚
â”‚       .lockBoost(new BN(boostAmount))                                   â”‚
â”‚       .accounts({                                                       â”‚
â”‚         user: wallet.publicKey,                                         â”‚
â”‚         userTokenAccount: userBoostATA,                                 â”‚
â”‚         vaultTokenAccount: vaultBoostATA,                               â”‚
â”‚         boostMint: LAIKA_MINT || TAKARA_MINT,                          â”‚
â”‚         depositState: depositPDA,                                       â”‚
â”‚         tokenProgram: TOKEN_PROGRAM_ID,                                 â”‚
â”‚       })                                                                â”‚
â”‚       .rpc();                                                           â”‚
â”‚     ```                                                                  â”‚
â”‚  4. Ğ–Ğ´Ğ°Ñ‚ÑŒ finalization                                                  â”‚
â”‚  5. Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ: solanaTxSignature                                        â”‚
â”‚                                                                          â”‚
â”‚  Backend Verification:                                                   â”‚
â”‚  1. ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ solanaTxSignature                                          â”‚
â”‚  2. Ğ—Ğ°Ğ¿Ñ€Ğ¾ÑĞ¸Ñ‚ÑŒ Solana RPC: getTransaction(signature)                     â”‚
â”‚  3. ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ:                                                          â”‚
â”‚     â€¢ Ğ˜Ğ½ÑÑ‚Ñ€ÑƒĞºÑ†Ğ¸Ñ == lockBoost                                           â”‚
â”‚     â€¢ amount >= requiredBoostAmount                                     â”‚
â”‚     â€¢ destination == vault PDA                                          â”‚
â”‚  4. ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ deposit record: boost_locked = true                        â”‚
â”‚                                                                          â”‚
â”‚  Status: PENDING_MINT                                                    â”‚
â”‚                                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                   â”‚
                                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ STEP 3: WEXEL NFT MINTING (SOLANA BLOCKCHAIN)                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                          â”‚
â”‚  Backend Preparation:                                                    â”‚
â”‚  1. Ğ¡Ğ¾Ğ±Ñ€Ğ°Ñ‚ÑŒ Ğ²ÑĞµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ´ĞµĞ¿Ğ¾Ğ·Ğ¸Ñ‚Ğ°:                                        â”‚
â”‚     ```typescript                                                        â”‚
â”‚     const depositData = {                                               â”‚
â”‚       depositId: deposit.id,                                            â”‚
â”‚       vaultType: deposit.vaultId,                                       â”‚
â”‚       amountUsdt: deposit.amountUsdt,                                   â”‚
â”‚       tronTxHash: deposit.tronTxHash,                                   â”‚
â”‚       baseApy: vault.baseApy,                                           â”‚
â”‚       boostApy: deposit.boostLocked ? vault.boostApy : 0,               â”‚
â”‚       lockPeriodMonths: vault.durationMonths,                           â”‚
â”‚       payoutFrequency: deposit.payoutFrequency,                         â”‚
â”‚       boostTokenMint: deposit.boostMint,                                â”‚
â”‚       boostTokenAmount: deposit.boostAmount,                            â”‚
â”‚       userSolanaWallet: deposit.solanaAddress,                          â”‚
â”‚     };                                                                  â”‚
â”‚     ```                                                                  â”‚
â”‚  2. Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑÑŒ Ğ´Ğ»Ñ Ğ¼Ğ¸Ğ½Ñ‚Ğ¸Ğ½Ğ³Ğ°:                                       â”‚
â”‚     ```typescript                                                        â”‚
â”‚     const message = Buffer.from(JSON.stringify(depositData));           â”‚
â”‚     const signature = nacl.sign.detached(message, BACKEND_KEYPAIR);     â”‚
â”‚     ```                                                                  â”‚
â”‚  3. Ğ’ĞµÑ€Ğ½ÑƒÑ‚ÑŒ signature + depositData Ğ½Ğ° Ñ„Ñ€Ğ¾Ğ½Ñ‚ĞµĞ½Ğ´                         â”‚
â”‚                                                                          â”‚
â”‚  Frontend:                                                               â”‚
â”‚  1. ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ signature Ğ¾Ñ‚ Ğ±ÑĞºĞµĞ½Ğ´Ğ°                                       â”‚
â”‚  2. Ğ’Ñ‹Ğ·Ğ²Ğ°Ñ‚ÑŒ Solana Program:                                             â”‚
â”‚     ```typescript                                                        â”‚
â”‚     const tx = await program.methods                                    â”‚
â”‚       .mintWexel(depositData, backendSignature)                         â”‚
â”‚       .accounts({                                                       â”‚
â”‚         user: wallet.publicKey,                                         â”‚
â”‚         wexelMint: wexelMintKeypair.publicKey,                         â”‚
â”‚         wexelMetadata: metadataPDA,                                     â”‚
â”‚         wexelState: wexelStatePDA,                                      â”‚
â”‚         collection: TAKARA_COLLECTION,                                  â”‚
â”‚         backendSigner: BACKEND_PUBKEY,                                  â”‚
â”‚         metadataProgram: METADATA_PROGRAM_ID,                           â”‚
â”‚         tokenProgram: TOKEN_PROGRAM_ID,                                 â”‚
â”‚         systemProgram: SystemProgram.programId,                         â”‚
â”‚       })                                                                â”‚
â”‚       .signers([wexelMintKeypair])                                      â”‚
â”‚       .rpc();                                                           â”‚
â”‚     ```                                                                  â”‚
â”‚  3. ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ ÑƒÑĞ¿ĞµÑ… + ÑÑÑ‹Ğ»ĞºÑƒ Ğ½Ğ° NFT                                      â”‚
â”‚                                                                          â”‚
â”‚  Smart Contract Verification (Ğ²Ğ½ÑƒÑ‚Ñ€Ğ¸ mintWexel):                        â”‚
â”‚  1. Verify backend signature                                            â”‚
â”‚  2. Verify deposit data integrity                                       â”‚
â”‚  3. Verify collection authority                                         â”‚
â”‚  4. Create Wexel NFT with metadata                                      â”‚
â”‚  5. Create WexelState PDA                                               â”‚
â”‚  6. Emit event: WexelMinted                                             â”‚
â”‚                                                                          â”‚
â”‚  Backend Post-Mint:                                                      â”‚
â”‚  1. ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ ÑĞ¾Ğ±Ñ‹Ñ‚Ğ¸Ğµ WexelMinted                                        â”‚
â”‚  2. ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ‘Ğ”: deposit.status = ACTIVE, deposit.wexelMint = mint      â”‚
â”‚                                                                          â”‚
â”‚  Status: ACTIVE                                                          â”‚
â”‚                                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
````

### 3.2 Ğ¡Ğ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ Ğ´ĞµĞ¿Ğ¾Ğ·Ğ¸Ñ‚Ğ° (State Machine)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      DEPOSIT STATE MACHINE                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     USDT TX      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  INITIAL  â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â”‚ PENDING_BOOST    â”‚ (ĞµÑĞ»Ğ¸ Ğ±ÑƒÑÑ‚)
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    confirmed     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                               â”‚
        â”‚ USDT TX                       â”‚ Boost TX
        â”‚ (Ğ±ĞµĞ· Ğ±ÑƒÑÑ‚Ğ°)                   â”‚ confirmed
        â–¼                               â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  PENDING_MINT    â”‚ â—„â”€â”€â”€â”€â”€â”€â”€â”€ â”‚  PENDING_MINT    â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â”‚ Wexel NFT
        â”‚ minted
        â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚     ACTIVE       â”‚ â—„â”€â”€â”€â”€â”€â”€â”€ Rewards accruing
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â”‚ Lock period
        â”‚ ended
        â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚    MATURED       â”‚ â—„â”€â”€â”€â”€â”€â”€â”€ Can redeem
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â”‚ NFT burned +
        â”‚ Principal returned
        â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚    REDEEMED      â”‚ â—„â”€â”€â”€â”€â”€â”€â”€ Final state
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Error States:
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ USDT_TX_FAILED   â”‚
  â”‚ BOOST_TX_FAILED  â”‚
  â”‚ MINT_FAILED      â”‚
  â”‚ EXPIRED          â”‚ (timeout waiting for next step)
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ—„ï¸ Ğ§ĞĞ¡Ğ¢Ğ¬ 4: DATABASE SCHEMA (Prisma)

### 4.1 ĞŸĞ¾Ğ»Ğ½Ğ°Ñ ÑÑ…ĞµĞ¼Ğ°

```prisma
// schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// ENUMS
// ============================================================================

enum VaultType {
  VAULT_1  // Starter (Laika Boost)
  VAULT_2  // Advanced (Takara Boost)
  VAULT_3  // Whale (Takara Boost)
}

enum DepositStatus {
  INITIAL
  PENDING_BOOST
  PENDING_MINT
  ACTIVE
  MATURED
  REDEEMED
  USDT_TX_FAILED
  BOOST_TX_FAILED
  MINT_FAILED
  EXPIRED
}

enum PayoutFrequency {
  MONTHLY    // x1.0
  QUARTERLY  // x1.15
  YEARLY     // x1.30
}

enum BoostToken {
  LAIKA
  TAKARA
  NONE
}

// ============================================================================
// CORE MODELS
// ============================================================================

model Vault {
  id                  Int         @id @default(autoincrement())
  name                String      // "Starter", "Advanced", "Whale"
  type                VaultType   @unique

  // Batch System
  currentBatchNumber  Int         @default(1)
  batchTargetAmount   Decimal     @default(100000) @db.Decimal(18, 2) // $100k

  // Financial Parameters â€” CORRECTED VALUES!
  durationMonths      Int
  minEntryUsdt        Decimal     @db.Decimal(18, 2)

  // APY (stored as basis points: 700 = 7.00%)
  baseApyBps          Int         // Vault1: calc, Vault2: 700, Vault3: 800
  boostApyBps         Int         // Vault1: calc, Vault2: 600, Vault3: 700
  maxApyBps           Int         // Vault1: 840, Vault2: 1300, Vault3: 1500

  // Takara Mining APR (basis points)
  takaraMiningAprBps  Int         // Vault1: 3000, Vault2: 3000, Vault3: 4000

  // Boost Configuration
  boostToken          BoostToken
  boostRatio          Decimal     @db.Decimal(5, 2) // 0.40 or 1.00
  boostPriceDiscount  Decimal     @db.Decimal(5, 2) // 0.15 or 0.00
  boostPriceFixed     Decimal?    @db.Decimal(18, 8) // null or 0.10

  // Relations
  batches             VaultBatch[]
  deposits            Deposit[]

  createdAt           DateTime    @default(now())
  updatedAt           DateTime    @updatedAt
}

model VaultBatch {
  id                  Int         @id @default(autoincrement())
  vaultId             Int
  vault               Vault       @relation(fields: [vaultId], references: [id])

  batchNumber         Int
  currentLiquidity    Decimal     @default(0) @db.Decimal(18, 2)
  targetLiquidity     Decimal     @db.Decimal(18, 2)

  isActive            Boolean     @default(true)
  isFilled            Boolean     @default(false)
  filledAt            DateTime?

  // Dates
  startDate           DateTime?   // When batch started accruing
  expectedEndDate     DateTime?   // startDate + durationMonths

  deposits            Deposit[]

  createdAt           DateTime    @default(now())
  updatedAt           DateTime    @updatedAt

  @@unique([vaultId, batchNumber])
  @@index([vaultId, isActive])
}

model Deposit {
  id                  Int           @id @default(autoincrement())

  // Vault & Batch Association
  vaultId             Int
  vault               Vault         @relation(fields: [vaultId], references: [id])
  batchId             Int?
  batch               VaultBatch?   @relation(fields: [batchId], references: [id])

  // User Wallets
  userTronAddress     String        @db.VarChar(42)  // TRC20 address
  userSolanaAddress   String        @db.VarChar(44)  // Solana pubkey
  currentOwnerSolana  String        @db.VarChar(44)  // Can change if NFT transferred!

  // Deposit Amount
  amountUsdt          Decimal       @db.Decimal(18, 6)

  // Status
  status              DepositStatus @default(INITIAL)

  // Transaction Hashes
  tronTxHash          String?       @db.VarChar(64)
  tronTxConfirmed     Boolean       @default(false)
  boostTxSignature    String?       @db.VarChar(88)  // Solana signature
  boostTxConfirmed    Boolean       @default(false)
  mintTxSignature     String?       @db.VarChar(88)

  // Wexel NFT
  wexelMintAddress    String?       @db.VarChar(44)  // Solana pubkey of NFT mint
  wexelMetadataUri    String?       // Arweave/IPFS URI

  // APY Configuration (frozen at deposit time)
  baseApyBps          Int
  boostApyBps         Int           @default(0)
  totalApyBps         Int           // baseApyBps + boostApyBps
  frequencyMultiplier Decimal       @db.Decimal(4, 2) // 1.00, 1.15, or 1.30
  effectiveApyBps     Int           // totalApyBps * frequencyMultiplier
  payoutFrequency     PayoutFrequency

  // Boost Details
  boostToken          BoostToken    @default(NONE)
  boostTokenMint      String?       @db.VarChar(44)
  boostTokenAmount    Decimal?      @db.Decimal(18, 9)
  boostTokenLocked    Boolean       @default(false)
  boostPriceAtDeposit Decimal?      @db.Decimal(18, 8) // For Laika: market price

  // Takara Mining
  takaraMiningAprBps  Int
  takaraPendingAmount Decimal       @default(0) @db.Decimal(18, 9)
  takaraClaimedTotal  Decimal       @default(0) @db.Decimal(18, 9)
  lastTakaraClaimAt   DateTime?

  // USDT Rewards
  usdtClaimedTotal    Decimal       @default(0) @db.Decimal(18, 6)
  lastUsdtClaimAt     DateTime?

  // Timing
  lockStartAt         DateTime?
  lockEndAt           DateTime?
  isMatured           Boolean       @default(false)
  isRedeemed          Boolean       @default(false)
  redeemedAt          DateTime?

  // Security
  claimNonce          Int           @default(0)

  createdAt           DateTime      @default(now())
  updatedAt           DateTime      @updatedAt

  // Relations
  claims              Claim[]
  transfers           WexelTransfer[]

  @@index([userTronAddress])
  @@index([userSolanaAddress])
  @@index([currentOwnerSolana])
  @@index([wexelMintAddress])
  @@index([status])
  @@index([vaultId, status])
}

model Claim {
  id                  Int         @id @default(autoincrement())
  depositId           Int
  deposit             Deposit     @relation(fields: [depositId], references: [id])

  claimType           String      // "USDT" or "TAKARA"
  amount              Decimal     @db.Decimal(18, 9)

  // Security
  nonce               Int
  signatureMessage    String      @db.Text
  userSignature       String      @db.VarChar(128)

  // Transaction
  txSignature         String?     @db.VarChar(88)
  txConfirmed         Boolean     @default(false)

  claimedAt           DateTime    @default(now())

  @@index([depositId])
  @@index([claimedAt])
}

model WexelTransfer {
  id                  Int         @id @default(autoincrement())
  depositId           Int
  deposit             Deposit     @relation(fields: [depositId], references: [id])

  fromWallet          String      @db.VarChar(44)
  toWallet            String      @db.VarChar(44)
  txSignature         String      @db.VarChar(88)

  transferredAt       DateTime    @default(now())

  @@index([depositId])
  @@index([txSignature])
}

// ============================================================================
// CONFIGURATION
// ============================================================================

model TakaraConfig {
  id                  Int         @id @default(1) // Singleton

  // Token Addresses
  takaraMintSolana    String      @db.VarChar(44)
  laikaMintSolana     String      @db.VarChar(44)
  usdtContractTron    String      @db.VarChar(42)

  // Treasury
  treasuryTronAddress String      @db.VarChar(42)
  treasurySolanaAddr  String      @db.VarChar(44)

  // Takara Internal Price (for Vault 2 & 3 boost calculation)
  takaraInternalPrice Decimal     @default(0.10) @db.Decimal(18, 8)

  // Program Addresses
  takaraProgramId     String      @db.VarChar(44)
  wexelCollectionAddr String      @db.VarChar(44)

  // Claim Rules
  minClaimIntervalVault1Hours Int @default(168) // 7 days in hours

  updatedAt           DateTime    @updatedAt
}

// ============================================================================
// PRICE FEEDS (for Laika)
// ============================================================================

model PriceFeed {
  id                  Int         @id @default(autoincrement())
  tokenSymbol         String      // "LAIKA"
  priceUsd            Decimal     @db.Decimal(18, 8)
  source              String      // "coingecko"
  fetchedAt           DateTime    @default(now())

  @@index([tokenSymbol, fetchedAt])
}
```

### 4.2 Seed Data (seeds/vaults.ts)

```typescript
// prisma/seeds/vaults.ts

import { PrismaClient, VaultType, BoostToken } from "@prisma/client";

const prisma = new PrismaClient();

async function seedVaults() {
  // ============================================================================
  // VAULT 1: Starter (Laika Boost)
  // ============================================================================
  await prisma.vault.upsert({
    where: { type: VaultType.VAULT_1 },
    update: {},
    create: {
      name: "Starter",
      type: VaultType.VAULT_1,
      durationMonths: 12,
      minEntryUsdt: 100,

      // APY: Max 8.40%, calculate base accordingly
      // If boost gives ~1.4% extra, base = 7.0%
      baseApyBps: 700, // 7.00%
      boostApyBps: 140, // 1.40%
      maxApyBps: 840, // 8.40%

      takaraMiningAprBps: 3000, // 30%

      boostToken: BoostToken.LAIKA,
      boostRatio: 0.4, // 40% of deposit
      boostPriceDiscount: 0.15, // 15% discount on market price
      boostPriceFixed: null, // Uses market price

      batchTargetAmount: 100000,
    },
  });

  // ============================================================================
  // VAULT 2: Advanced (Takara Boost) â€” CORRECTED!
  // ============================================================================
  await prisma.vault.upsert({
    where: { type: VaultType.VAULT_2 },
    update: {
      // UPDATE existing record with correct values!
      baseApyBps: 700, // 7.00% â€” WAS WRONG!
      boostApyBps: 600, // 6.00% â€” WAS WRONG!
      maxApyBps: 1300, // 13.00% â€” WAS WRONG!
    },
    create: {
      name: "Advanced",
      type: VaultType.VAULT_2,
      durationMonths: 30,
      minEntryUsdt: 1500,

      // CORRECTED APY VALUES!
      baseApyBps: 700, // 7.00% Start APY
      boostApyBps: 600, // +6.00% Takara Boost
      maxApyBps: 1300, // 13.00% Max APY

      takaraMiningAprBps: 3000, // 30%

      boostToken: BoostToken.TAKARA,
      boostRatio: 1.0, // 1:1 to deposit
      boostPriceDiscount: 0.0, // No discount
      boostPriceFixed: 0.1, // Fixed $0.10

      batchTargetAmount: 100000,
    },
  });

  // ============================================================================
  // VAULT 3: Whale (Takara Boost) â€” CORRECTED!
  // ============================================================================
  await prisma.vault.upsert({
    where: { type: VaultType.VAULT_3 },
    update: {
      // UPDATE existing record with correct values!
      baseApyBps: 800, // 8.00% â€” WAS WRONG!
      boostApyBps: 700, // 7.00% â€” WAS WRONG!
      maxApyBps: 1500, // 15.00% â€” WAS WRONG!
    },
    create: {
      name: "Whale",
      type: VaultType.VAULT_3,
      durationMonths: 36,
      minEntryUsdt: 5000,

      // CORRECTED APY VALUES!
      baseApyBps: 800, // 8.00% Start APY
      boostApyBps: 700, // +7.00% Takara Boost
      maxApyBps: 1500, // 15.00% Max APY

      takaraMiningAprBps: 4000, // 40%

      boostToken: BoostToken.TAKARA,
      boostRatio: 1.0, // 1:1 to deposit
      boostPriceDiscount: 0.0, // No discount
      boostPriceFixed: 0.1, // Fixed $0.10

      batchTargetAmount: 100000,
    },
  });

  console.log("âœ… Vaults seeded with CORRECTED APY values!");
}

seedVaults()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
```

---

## âš™ï¸ Ğ§ĞĞ¡Ğ¢Ğ¬ 5: BACKEND (NestJS)

### 5.1 Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ° Ğ¼Ğ¾Ğ´ÑƒĞ»ĞµĞ¹

```
src/
â”œâ”€â”€ app.module.ts
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ configuration.ts
â”‚   â””â”€â”€ validation.ts
â”œâ”€â”€ common/
â”‚   â”œâ”€â”€ decorators/
â”‚   â”œâ”€â”€ guards/
â”‚   â”‚   â”œâ”€â”€ solana-signature.guard.ts    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑĞ¸ Solana
â”‚   â”‚   â””â”€â”€ tron-signature.guard.ts      # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑĞ¸ Tron
â”‚   â”œâ”€â”€ interceptors/
â”‚   â””â”€â”€ filters/
â”œâ”€â”€ modules/
â”‚   â”œâ”€â”€ vaults/                          # Renamed from pools!
â”‚   â”‚   â”œâ”€â”€ vaults.module.ts
â”‚   â”‚   â”œâ”€â”€ vaults.controller.ts
â”‚   â”‚   â”œâ”€â”€ vaults.service.ts
â”‚   â”‚   â””â”€â”€ dto/
â”‚   â”‚       â”œâ”€â”€ vault.dto.ts
â”‚   â”‚       â””â”€â”€ vault-batch.dto.ts
â”‚   â”œâ”€â”€ deposits/
â”‚   â”‚   â”œâ”€â”€ deposits.module.ts
â”‚   â”‚   â”œâ”€â”€ deposits.controller.ts
â”‚   â”‚   â”œâ”€â”€ deposits.service.ts
â”‚   â”‚   â”œâ”€â”€ deposit-flow.service.ts      # Multi-chain flow orchestration
â”‚   â”‚   â””â”€â”€ dto/
â”‚   â”‚       â”œâ”€â”€ create-deposit.dto.ts
â”‚   â”‚       â”œâ”€â”€ confirm-tron-tx.dto.ts
â”‚   â”‚       â”œâ”€â”€ confirm-boost-tx.dto.ts
â”‚   â”‚       â””â”€â”€ mint-wexel.dto.ts
â”‚   â”œâ”€â”€ wexel/
â”‚   â”‚   â”œâ”€â”€ wexel.module.ts
â”‚   â”‚   â”œâ”€â”€ wexel.service.ts             # NFT operations
â”‚   â”‚   â”œâ”€â”€ wexel-verification.service.ts # Ownership verification
â”‚   â”‚   â””â”€â”€ wexel-monitor.service.ts     # Transfer monitoring
â”‚   â”œâ”€â”€ claims/
â”‚   â”‚   â”œâ”€â”€ claims.module.ts
â”‚   â”‚   â”œâ”€â”€ claims.controller.ts
â”‚   â”‚   â”œâ”€â”€ claims.service.ts
â”‚   â”‚   â””â”€â”€ dto/
â”‚   â”‚       â”œâ”€â”€ claim-usdt.dto.ts
â”‚   â”‚       â””â”€â”€ claim-takara.dto.ts
â”‚   â”œâ”€â”€ blockchain/
â”‚   â”‚   â”œâ”€â”€ blockchain.module.ts
â”‚   â”‚   â”œâ”€â”€ tron/
â”‚   â”‚   â”‚   â”œâ”€â”€ tron.service.ts          # Tron RPC interactions
â”‚   â”‚   â”‚   â””â”€â”€ tron-monitor.service.ts  # TX confirmation monitoring
â”‚   â”‚   â””â”€â”€ solana/
â”‚   â”‚       â”œâ”€â”€ solana.service.ts        # Solana RPC interactions
â”‚   â”‚       â”œâ”€â”€ solana-program.service.ts # Anchor program calls
â”‚   â”‚       â””â”€â”€ solana-monitor.service.ts # Events monitoring
â”‚   â”œâ”€â”€ price-feed/
â”‚   â”‚   â”œâ”€â”€ price-feed.module.ts
â”‚   â”‚   â””â”€â”€ price-feed.service.ts        # CoinGecko integration
â”‚   â””â”€â”€ calculator/
â”‚       â”œâ”€â”€ calculator.module.ts
â”‚       â””â”€â”€ yield-calculator.service.ts  # APY/reward calculations
â””â”€â”€ prisma/
    â”œâ”€â”€ prisma.module.ts
    â””â”€â”€ prisma.service.ts
```

### 5.2 ĞšĞ»ÑÑ‡ĞµĞ²Ñ‹Ğµ ÑĞµÑ€Ğ²Ğ¸ÑÑ‹

#### 5.2.1 Deposit Flow Service

```typescript
// src/modules/deposits/deposit-flow.service.ts

import { Injectable, BadRequestException } from "@nestjs/common";
import { PrismaService } from "@/prisma/prisma.service";
import { TronService } from "@/modules/blockchain/tron/tron.service";
import { SolanaService } from "@/modules/blockchain/solana/solana.service";
import { WexelService } from "@/modules/wexel/wexel.service";
import { YieldCalculatorService } from "@/modules/calculator/yield-calculator.service";
import { DepositStatus, PayoutFrequency, BoostToken } from "@prisma/client";

@Injectable()
export class DepositFlowService {
  constructor(
    private prisma: PrismaService,
    private tronService: TronService,
    private solanaService: SolanaService,
    private wexelService: WexelService,
    private yieldCalculator: YieldCalculatorService
  ) {}

  /**
   * STEP 0: Initialize deposit record
   */
  async initializeDeposit(dto: {
    vaultId: number;
    amountUsdt: number;
    userTronAddress: string;
    userSolanaAddress: string;
    payoutFrequency: PayoutFrequency;
    enableBoost: boolean;
  }) {
    const vault = await this.prisma.vault.findUniqueOrThrow({
      where: { id: dto.vaultId },
    });

    // Validate minimum entry
    if (dto.amountUsdt < Number(vault.minEntryUsdt)) {
      throw new BadRequestException(`Minimum deposit for ${vault.name} is $${vault.minEntryUsdt}`);
    }

    // Calculate APY
    const apyConfig = this.yieldCalculator.calculateApy({
      vault,
      enableBoost: dto.enableBoost,
      payoutFrequency: dto.payoutFrequency,
    });

    // Get active batch
    const activeBatch = await this.getOrCreateActiveBatch(vault.id);

    // Create deposit record
    const deposit = await this.prisma.deposit.create({
      data: {
        vaultId: vault.id,
        batchId: activeBatch.id,
        userTronAddress: dto.userTronAddress,
        userSolanaAddress: dto.userSolanaAddress,
        currentOwnerSolana: dto.userSolanaAddress,
        amountUsdt: dto.amountUsdt,
        status: DepositStatus.INITIAL,

        // APY config
        baseApyBps: vault.baseApyBps,
        boostApyBps: dto.enableBoost ? vault.boostApyBps : 0,
        totalApyBps: apyConfig.totalApyBps,
        frequencyMultiplier: apyConfig.frequencyMultiplier,
        effectiveApyBps: apyConfig.effectiveApyBps,
        payoutFrequency: dto.payoutFrequency,

        // Boost config
        boostToken: dto.enableBoost ? vault.boostToken : BoostToken.NONE,
        boostTokenMint: dto.enableBoost ? await this.getBoostTokenMint(vault.boostToken) : null,

        // Takara mining
        takaraMiningAprBps: vault.takaraMiningAprBps,
      },
    });

    return {
      depositId: deposit.id,
      nextStep: "CONFIRM_TRON_TX",
      treasuryAddress: await this.getTreasuryTronAddress(),
      amountUsdt: dto.amountUsdt,
      apyConfig,
      boostRequired: dto.enableBoost
        ? await this.calculateBoostRequired(vault, dto.amountUsdt)
        : null,
    };
  }

  /**
   * STEP 1: Confirm USDT Tron transaction
   */
  async confirmTronTransaction(dto: { depositId: number; tronTxHash: string }) {
    const deposit = await this.prisma.deposit.findUniqueOrThrow({
      where: { id: dto.depositId },
      include: { vault: true },
    });

    if (deposit.status !== DepositStatus.INITIAL) {
      throw new BadRequestException("Invalid deposit status for this step");
    }

    // Verify transaction on Tron
    const txVerification = await this.tronService.verifyUsdtTransfer({
      txHash: dto.tronTxHash,
      expectedAmount: Number(deposit.amountUsdt),
      fromAddress: deposit.userTronAddress,
    });

    if (!txVerification.valid) {
      await this.prisma.deposit.update({
        where: { id: dto.depositId },
        data: { status: DepositStatus.USDT_TX_FAILED },
      });
      throw new BadRequestException(txVerification.error);
    }

    // Determine next status
    const nextStatus =
      deposit.boostToken !== BoostToken.NONE
        ? DepositStatus.PENDING_BOOST
        : DepositStatus.PENDING_MINT;

    await this.prisma.deposit.update({
      where: { id: dto.depositId },
      data: {
        tronTxHash: dto.tronTxHash,
        tronTxConfirmed: true,
        status: nextStatus,
      },
    });

    return {
      success: true,
      nextStep: nextStatus === DepositStatus.PENDING_BOOST ? "LOCK_BOOST_TOKENS" : "MINT_WEXEL",
    };
  }

  /**
   * STEP 2: Confirm boost token lock (Solana)
   */
  async confirmBoostLock(dto: { depositId: number; solanaTxSignature: string }) {
    const deposit = await this.prisma.deposit.findUniqueOrThrow({
      where: { id: dto.depositId },
      include: { vault: true },
    });

    if (deposit.status !== DepositStatus.PENDING_BOOST) {
      throw new BadRequestException("Invalid deposit status for this step");
    }

    // Calculate required boost amount
    const boostRequired = await this.calculateBoostRequired(
      deposit.vault,
      Number(deposit.amountUsdt)
    );

    // Verify transaction on Solana
    const txVerification = await this.solanaService.verifyBoostLock({
      txSignature: dto.solanaTxSignature,
      expectedAmount: boostRequired.amount,
      tokenMint: deposit.boostTokenMint!,
      fromWallet: deposit.userSolanaAddress,
    });

    if (!txVerification.valid) {
      await this.prisma.deposit.update({
        where: { id: dto.depositId },
        data: { status: DepositStatus.BOOST_TX_FAILED },
      });
      throw new BadRequestException(txVerification.error);
    }

    await this.prisma.deposit.update({
      where: { id: dto.depositId },
      data: {
        boostTxSignature: dto.solanaTxSignature,
        boostTxConfirmed: true,
        boostTokenAmount: boostRequired.amount,
        boostTokenLocked: true,
        boostPriceAtDeposit: boostRequired.priceUsed,
        status: DepositStatus.PENDING_MINT,
      },
    });

    return {
      success: true,
      nextStep: "MINT_WEXEL",
    };
  }

  /**
   * STEP 3: Generate mint signature for Wexel NFT
   */
  async generateMintSignature(depositId: number) {
    const deposit = await this.prisma.deposit.findUniqueOrThrow({
      where: { id: depositId },
      include: { vault: true },
    });

    if (deposit.status !== DepositStatus.PENDING_MINT) {
      throw new BadRequestException("Invalid deposit status for minting");
    }

    // Generate backend signature for mint authorization
    const mintData = this.wexelService.prepareMintData(deposit);
    const signature = await this.wexelService.signMintAuthorization(mintData);

    return {
      mintData,
      backendSignature: signature,
      programId: await this.getTakaraProgramId(),
      collectionAddress: await this.getWexelCollectionAddress(),
    };
  }

  /**
   * STEP 3b: Confirm Wexel mint
   */
  async confirmWexelMint(dto: {
    depositId: number;
    mintTxSignature: string;
    wexelMintAddress: string;
  }) {
    const deposit = await this.prisma.deposit.findUniqueOrThrow({
      where: { id: dto.depositId },
    });

    if (deposit.status !== DepositStatus.PENDING_MINT) {
      throw new BadRequestException("Invalid deposit status");
    }

    // Verify mint on Solana
    const mintVerification = await this.solanaService.verifyWexelMint({
      txSignature: dto.mintTxSignature,
      wexelMint: dto.wexelMintAddress,
      expectedOwner: deposit.userSolanaAddress,
    });

    if (!mintVerification.valid) {
      await this.prisma.deposit.update({
        where: { id: dto.depositId },
        data: { status: DepositStatus.MINT_FAILED },
      });
      throw new BadRequestException(mintVerification.error);
    }

    // Calculate lock dates
    const lockStartAt = new Date();
    const lockEndAt = new Date(lockStartAt);
    lockEndAt.setMonth(lockEndAt.getMonth() + deposit.vault.durationMonths);

    await this.prisma.deposit.update({
      where: { id: dto.depositId },
      data: {
        mintTxSignature: dto.mintTxSignature,
        wexelMintAddress: dto.wexelMintAddress,
        wexelMetadataUri: mintVerification.metadataUri,
        status: DepositStatus.ACTIVE,
        lockStartAt,
        lockEndAt,
      },
    });

    // Update batch liquidity
    await this.updateBatchLiquidity(deposit.batchId!, Number(deposit.amountUsdt));

    return {
      success: true,
      wexelMintAddress: dto.wexelMintAddress,
      lockStartAt,
      lockEndAt,
    };
  }

  // ... helper methods
}
```

#### 5.2.2 Yield Calculator Service

```typescript
// src/modules/calculator/yield-calculator.service.ts

import { Injectable } from "@nestjs/common";
import { Vault, PayoutFrequency } from "@prisma/client";
import Decimal from "decimal.js";

@Injectable()
export class YieldCalculatorService {
  // Frequency multipliers
  private readonly FREQUENCY_MULTIPLIERS = {
    [PayoutFrequency.MONTHLY]: new Decimal(1.0),
    [PayoutFrequency.QUARTERLY]: new Decimal(1.15),
    [PayoutFrequency.YEARLY]: new Decimal(1.3),
  };

  /**
   * Calculate APY configuration for deposit
   */
  calculateApy(params: { vault: Vault; enableBoost: boolean; payoutFrequency: PayoutFrequency }) {
    const { vault, enableBoost, payoutFrequency } = params;

    const baseApyBps = vault.baseApyBps;
    const boostApyBps = enableBoost ? vault.boostApyBps : 0;
    const totalApyBps = baseApyBps + boostApyBps;

    const multiplier = this.FREQUENCY_MULTIPLIERS[payoutFrequency];
    const effectiveApyBps = new Decimal(totalApyBps).mul(multiplier).toNumber();

    return {
      baseApyBps,
      boostApyBps,
      totalApyBps,
      frequencyMultiplier: multiplier.toNumber(),
      effectiveApyBps: Math.round(effectiveApyBps),

      // Human readable
      baseApyPercent: (baseApyBps / 100).toFixed(2),
      boostApyPercent: (boostApyBps / 100).toFixed(2),
      totalApyPercent: (totalApyBps / 100).toFixed(2),
      effectiveApyPercent: (effectiveApyBps / 100).toFixed(2),
    };
  }

  /**
   * Calculate pending USDT rewards
   */
  calculatePendingUsdtRewards(params: {
    depositAmountUsdt: Decimal;
    effectiveApyBps: number;
    lockStartAt: Date;
    lastClaimAt: Date | null;
    payoutFrequency: PayoutFrequency;
  }): Decimal {
    const { depositAmountUsdt, effectiveApyBps, lockStartAt, lastClaimAt, payoutFrequency } =
      params;

    const now = new Date();
    const startDate = lastClaimAt || lockStartAt;

    // Calculate days elapsed
    const msPerDay = 24 * 60 * 60 * 1000;
    const daysElapsed = Math.floor((now.getTime() - startDate.getTime()) / msPerDay);

    if (daysElapsed <= 0) return new Decimal(0);

    // Daily rate from APY
    const annualRate = new Decimal(effectiveApyBps).div(10000);
    const dailyRate = annualRate.div(365);

    // Rewards = principal * dailyRate * days
    const rewards = new Decimal(depositAmountUsdt).mul(dailyRate).mul(daysElapsed);

    return rewards;
  }

  /**
   * Calculate pending Takara mining rewards
   */
  calculatePendingTakaraRewards(params: {
    depositAmountUsdt: Decimal;
    takaraMiningAprBps: number;
    lockStartAt: Date;
    lastClaimAt: Date | null;
  }): Decimal {
    const { depositAmountUsdt, takaraMiningAprBps, lockStartAt, lastClaimAt } = params;

    const now = new Date();
    const startDate = lastClaimAt || lockStartAt;

    const msPerDay = 24 * 60 * 60 * 1000;
    const daysElapsed = Math.floor((now.getTime() - startDate.getTime()) / msPerDay);

    if (daysElapsed <= 0) return new Decimal(0);

    // Daily rate from APR
    const annualRate = new Decimal(takaraMiningAprBps).div(10000);
    const dailyRate = annualRate.div(365);

    // Takara rewarded based on USDT deposit at internal price $0.10
    // rewards_takara = (deposit_usdt * dailyRate * days) / 0.10
    const usdtValue = new Decimal(depositAmountUsdt).mul(dailyRate).mul(daysElapsed);
    const takaraRewards = usdtValue.div(0.1);

    return takaraRewards;
  }
}
```

#### 5.2.3 Wexel Verification Service

```typescript
// src/modules/wexel/wexel-verification.service.ts

import { Injectable, UnauthorizedException } from "@nestjs/common";
import { PrismaService } from "@/prisma/prisma.service";
import { SolanaService } from "@/modules/blockchain/solana/solana.service";
import * as nacl from "tweetnacl";
import * as bs58 from "bs58";

@Injectable()
export class WexelVerificationService {
  constructor(
    private prisma: PrismaService,
    private solanaService: SolanaService
  ) {}

  /**
   * Verify that a wallet owns a specific Wexel NFT
   * This is the CRITICAL security check for all claim operations
   */
  async verifyWexelOwnership(params: {
    wexelMintAddress: string;
    claimerWallet: string;
  }): Promise<{ valid: boolean; error?: string }> {
    const { wexelMintAddress, claimerWallet } = params;

    // 1. Get token account for this NFT
    const tokenAccounts = await this.solanaService.getTokenAccountsByOwner(
      claimerWallet,
      wexelMintAddress
    );

    if (tokenAccounts.length === 0) {
      return {
        valid: false,
        error: "Wallet does not own this Wexel NFT",
      };
    }

    // 2. Verify NFT is from TAKARA collection
    const nftMetadata = await this.solanaService.getNftMetadata(wexelMintAddress);

    const config = await this.prisma.takaraConfig.findFirst();
    if (nftMetadata.collection !== config?.wexelCollectionAddr) {
      return {
        valid: false,
        error: "NFT is not from TAKARA collection",
      };
    }

    // 3. Verify creator is verified
    if (!nftMetadata.creators?.[0]?.verified) {
      return {
        valid: false,
        error: "NFT creator not verified - possible forgery",
      };
    }

    return { valid: true };
  }

  /**
   * Verify signed claim request
   */
  async verifyClaimSignature(params: {
    depositId: number;
    claimerWallet: string;
    signature: string;
    message: string;
    nonce: number;
    timestamp: number;
  }): Promise<{ valid: boolean; error?: string }> {
    const { depositId, claimerWallet, signature, message, nonce, timestamp } = params;

    // 1. Check timestamp (not older than 5 minutes)
    const now = Date.now();
    const maxAge = 5 * 60 * 1000; // 5 minutes
    if (now - timestamp > maxAge) {
      return { valid: false, error: "Signature expired" };
    }

    // 2. Reconstruct expected message
    const expectedMessage = `claim:${depositId}:${nonce}:${timestamp}`;
    if (message !== expectedMessage) {
      return { valid: false, error: "Invalid message format" };
    }

    // 3. Verify nonce (must be greater than last used)
    const deposit = await this.prisma.deposit.findUnique({
      where: { id: depositId },
    });

    if (!deposit) {
      return { valid: false, error: "Deposit not found" };
    }

    if (nonce <= deposit.claimNonce) {
      return { valid: false, error: "Nonce already used - replay attack detected" };
    }

    // 4. Verify signature
    try {
      const messageBytes = new TextEncoder().encode(message);
      const signatureBytes = bs58.decode(signature);
      const publicKeyBytes = bs58.decode(claimerWallet);

      const isValid = nacl.sign.detached.verify(messageBytes, signatureBytes, publicKeyBytes);

      if (!isValid) {
        return { valid: false, error: "Invalid signature" };
      }
    } catch (err) {
      return { valid: false, error: "Signature verification failed" };
    }

    // 5. Verify ownership
    const ownershipCheck = await this.verifyWexelOwnership({
      wexelMintAddress: deposit.wexelMintAddress!,
      claimerWallet,
    });

    if (!ownershipCheck.valid) {
      return ownershipCheck;
    }

    return { valid: true };
  }
}
```

---

## ğŸ–¥ï¸ Ğ§ĞĞ¡Ğ¢Ğ¬ 6: FRONTEND (Next.js)

### 6.1 ĞšĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚Ñ‹ Deposit Wizard

```tsx
// components/deposit/DepositWizard.tsx

"use client";

import { useState } from "react";
import { useWallet as useSolanaWallet } from "@solana/wallet-adapter-react";
import { useTronWallet } from "@/hooks/useTronWallet";
import { WalletConnectionStep } from "./steps/WalletConnectionStep";
import { VaultSelectionStep } from "./steps/VaultSelectionStep";
import { TronDepositStep } from "./steps/TronDepositStep";
import { BoostLockStep } from "./steps/BoostLockStep";
import { WexelMintStep } from "./steps/WexelMintStep";
import { SuccessStep } from "./steps/SuccessStep";

type WizardStep =
  | "WALLET_CONNECTION"
  | "VAULT_SELECTION"
  | "TRON_DEPOSIT"
  | "BOOST_LOCK"
  | "WEXEL_MINT"
  | "SUCCESS";

interface DepositState {
  vaultId: number | null;
  amountUsdt: number;
  payoutFrequency: "MONTHLY" | "QUARTERLY" | "YEARLY";
  enableBoost: boolean;
  depositId: number | null;
  tronTxHash: string | null;
  boostTxSignature: string | null;
  wexelMintAddress: string | null;
}

export function DepositWizard() {
  const [currentStep, setCurrentStep] = useState<WizardStep>("WALLET_CONNECTION");
  const [depositState, setDepositState] = useState<DepositState>({
    vaultId: null,
    amountUsdt: 0,
    payoutFrequency: "MONTHLY",
    enableBoost: false,
    depositId: null,
    tronTxHash: null,
    boostTxSignature: null,
    wexelMintAddress: null,
  });

  const solanaWallet = useSolanaWallet();
  const tronWallet = useTronWallet();

  const renderStep = () => {
    switch (currentStep) {
      case "WALLET_CONNECTION":
        return (
          <WalletConnectionStep
            solanaConnected={solanaWallet.connected}
            tronConnected={tronWallet.connected}
            onContinue={() => setCurrentStep("VAULT_SELECTION")}
          />
        );

      case "VAULT_SELECTION":
        return (
          <VaultSelectionStep
            onSelect={(vaultId, amountUsdt, payoutFrequency, enableBoost) => {
              setDepositState((prev) => ({
                ...prev,
                vaultId,
                amountUsdt,
                payoutFrequency,
                enableBoost,
              }));
              setCurrentStep("TRON_DEPOSIT");
            }}
            onBack={() => setCurrentStep("WALLET_CONNECTION")}
          />
        );

      case "TRON_DEPOSIT":
        return (
          <TronDepositStep
            amountUsdt={depositState.amountUsdt}
            tronWallet={tronWallet}
            onSuccess={(depositId, txHash) => {
              setDepositState((prev) => ({
                ...prev,
                depositId,
                tronTxHash: txHash,
              }));
              setCurrentStep(depositState.enableBoost ? "BOOST_LOCK" : "WEXEL_MINT");
            }}
            onBack={() => setCurrentStep("VAULT_SELECTION")}
          />
        );

      case "BOOST_LOCK":
        return (
          <BoostLockStep
            depositId={depositState.depositId!}
            solanaWallet={solanaWallet}
            onSuccess={(txSignature) => {
              setDepositState((prev) => ({
                ...prev,
                boostTxSignature: txSignature,
              }));
              setCurrentStep("WEXEL_MINT");
            }}
            onBack={() => setCurrentStep("TRON_DEPOSIT")}
          />
        );

      case "WEXEL_MINT":
        return (
          <WexelMintStep
            depositId={depositState.depositId!}
            solanaWallet={solanaWallet}
            onSuccess={(wexelMintAddress) => {
              setDepositState((prev) => ({
                ...prev,
                wexelMintAddress,
              }));
              setCurrentStep("SUCCESS");
            }}
          />
        );

      case "SUCCESS":
        return (
          <SuccessStep
            wexelMintAddress={depositState.wexelMintAddress!}
            depositId={depositState.depositId!}
          />
        );
    }
  };

  return (
    <div className="max-w-2xl mx-auto">
      {/* Progress Bar */}
      <div className="mb-8">
        <StepProgress currentStep={currentStep} hasBoost={depositState.enableBoost} />
      </div>

      {/* Step Content */}
      <div className="bg-gray-900 rounded-2xl p-8">{renderStep()}</div>
    </div>
  );
}
```

### 6.2 Vault Card Ñ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ñ‹Ğ¼Ğ¸ APY

```tsx
// components/vaults/VaultCard.tsx

interface VaultCardProps {
  vault: {
    id: number;
    name: string;
    type: "VAULT_1" | "VAULT_2" | "VAULT_3";
    durationMonths: number;
    minEntryUsdt: number;
    baseApyBps: number; // CORRECTED VALUES!
    boostApyBps: number; // CORRECTED VALUES!
    maxApyBps: number; // CORRECTED VALUES!
    boostToken: "LAIKA" | "TAKARA" | "NONE";
    boostRatio: number;
    boostPriceDiscount: number;
    boostPriceFixed: number | null;
  };
}

export function VaultCard({ vault }: VaultCardProps) {
  const baseApyPercent = (vault.baseApyBps / 100).toFixed(2);
  const boostApyPercent = (vault.boostApyBps / 100).toFixed(2);
  const maxApyPercent = (vault.maxApyBps / 100).toFixed(2);

  // Calculate max APY with Yearly multiplier
  const maxApyWithYearly = ((vault.maxApyBps * 1.3) / 100).toFixed(2);

  return (
    <div className="bg-gradient-to-br from-gray-800 to-gray-900 rounded-2xl p-6 border border-gray-700">
      {/* Header */}
      <div className="flex justify-between items-start mb-6">
        <div>
          <h3 className="text-2xl font-bold text-white">{vault.name}</h3>
          <p className="text-gray-400">{vault.durationMonths} months lock</p>
        </div>
        <VaultBadge type={vault.type} />
      </div>

      {/* APY Display */}
      <div className="space-y-4 mb-6">
        {/* Base APY */}
        <div className="flex justify-between">
          <span className="text-gray-400">Start APY (USDT only)</span>
          <span className="text-white font-semibold">{baseApyPercent}%</span>
        </div>

        {/* Boost APY */}
        {vault.boostToken !== "NONE" && (
          <div className="flex justify-between">
            <span className="text-gray-400">{vault.boostToken} Boost</span>
            <span className="text-green-400 font-semibold">+{boostApyPercent}%</span>
          </div>
        )}

        {/* Max APY */}
        <div className="flex justify-between border-t border-gray-700 pt-4">
          <span className="text-gray-400">Max APY (with boost)</span>
          <span className="text-xl text-yellow-400 font-bold">{maxApyPercent}%</span>
        </div>

        {/* Max APY with Yearly */}
        <div className="flex justify-between">
          <span className="text-gray-500 text-sm">Max APY (Yearly payout)</span>
          <span className="text-yellow-300 text-sm">up to {maxApyWithYearly}%</span>
        </div>
      </div>

      {/* Boost Condition */}
      {vault.boostToken !== "NONE" && (
        <div className="bg-gray-700/50 rounded-lg p-4 mb-6">
          <p className="text-sm text-gray-300">
            <span className="font-semibold text-white">Boost Condition: </span>
            {vault.boostToken === "LAIKA" ? (
              <>
                Hold <span className="text-purple-400">Laika</span> = {vault.boostRatio * 100}% of
                deposit
                <br />
                <span className="text-gray-500">
                  (Market price with {vault.boostPriceDiscount * 100}% discount)
                </span>
              </>
            ) : (
              <>
                Hold <span className="text-blue-400">Takara</span> = 1:1 to deposit
                <br />
                <span className="text-gray-500">
                  (Fixed price: ${vault.boostPriceFixed?.toFixed(2)})
                </span>
              </>
            )}
          </p>
        </div>
      )}

      {/* Min Entry */}
      <div className="flex justify-between items-center mb-6">
        <span className="text-gray-400">Minimum Entry</span>
        <span className="text-white font-semibold">
          ${vault.minEntryUsdt.toLocaleString()} USDT
        </span>
      </div>

      {/* CTA Button */}
      <button className="w-full py-3 bg-gradient-to-r from-blue-600 to-purple-600 rounded-lg font-semibold text-white hover:from-blue-500 hover:to-purple-500 transition-all">
        Deposit Now
      </button>
    </div>
  );
}
```

---

## â›“ï¸ Ğ§ĞĞ¡Ğ¢Ğ¬ 7: SMART CONTRACTS (Solana/Anchor)

### 7.1 Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ° Ğ¿Ñ€Ğ¾Ğ³Ñ€Ğ°Ğ¼Ğ¼Ñ‹

```
programs/takara/
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ Xargo.toml
â””â”€â”€ src/
    â”œâ”€â”€ lib.rs              # Entry point
    â”œâ”€â”€ instructions/
    â”‚   â”œâ”€â”€ mod.rs
    â”‚   â”œâ”€â”€ initialize.rs   # Initialize program state
    â”‚   â”œâ”€â”€ lock_boost.rs   # Lock Laika/Takara for boost
    â”‚   â”œâ”€â”€ mint_wexel.rs   # Mint Wexel NFT
    â”‚   â”œâ”€â”€ claim_usdt.rs   # Claim USDT rewards (signature)
    â”‚   â”œâ”€â”€ claim_takara.rs # Claim Takara mining rewards
    â”‚   â”œâ”€â”€ unlock_boost.rs # Unlock boost tokens on redeem
    â”‚   â””â”€â”€ burn_wexel.rs   # Burn NFT on redemption
    â”œâ”€â”€ state/
    â”‚   â”œâ”€â”€ mod.rs
    â”‚   â”œâ”€â”€ program_config.rs
    â”‚   â”œâ”€â”€ wexel_state.rs  # PDA for each Wexel NFT
    â”‚   â””â”€â”€ boost_vault.rs  # Token vault for locked boost
    â”œâ”€â”€ errors.rs
    â””â”€â”€ events.rs
```

### 7.2 Core Instructions

```rust
// programs/takara/src/lib.rs

use anchor_lang::prelude::*;

declare_id!("TAKARA_PROGRAM_ID_HERE");

pub mod instructions;
pub mod state;
pub mod errors;
pub mod events;

use instructions::*;

#[program]
pub mod takara {
    use super::*;

    /// Initialize program configuration
    pub fn initialize(
        ctx: Context<Initialize>,
        config: ProgramConfigInput,
    ) -> Result<()> {
        instructions::initialize::handler(ctx, config)
    }

    /// Lock boost tokens (Laika or Takara)
    pub fn lock_boost(
        ctx: Context<LockBoost>,
        amount: u64,
        deposit_id: u64,
    ) -> Result<()> {
        instructions::lock_boost::handler(ctx, amount, deposit_id)
    }

    /// Mint Wexel NFT after verified deposit
    pub fn mint_wexel(
        ctx: Context<MintWexel>,
        mint_data: WexelMintData,
        backend_signature: [u8; 64],
    ) -> Result<()> {
        instructions::mint_wexel::handler(ctx, mint_data, backend_signature)
    }

    /// Claim Takara mining rewards
    pub fn claim_takara(
        ctx: Context<ClaimTakara>,
        amount: u64,
        nonce: u64,
        timestamp: i64,
        backend_signature: [u8; 64],
    ) -> Result<()> {
        instructions::claim_takara::handler(ctx, amount, nonce, timestamp, backend_signature)
    }

    /// Unlock boost tokens and burn Wexel (redemption)
    pub fn redeem_wexel(
        ctx: Context<RedeemWexel>,
        backend_signature: [u8; 64],
    ) -> Result<()> {
        instructions::redeem_wexel::handler(ctx, backend_signature)
    }
}
```

### 7.3 Wexel State (PDA)

```rust
// programs/takara/src/state/wexel_state.rs

use anchor_lang::prelude::*;

#[account]
pub struct WexelState {
    /// Bump seed for PDA derivation
    pub bump: u8,

    /// Associated NFT mint address
    pub wexel_mint: Pubkey,

    /// Original depositor (for tracking, not ownership!)
    pub original_depositor: Pubkey,

    /// Backend deposit ID (for cross-reference)
    pub deposit_id: u64,

    /// Deposit details (immutable)
    pub vault_type: u8,             // 1, 2, or 3
    pub deposit_amount_usdt: u64,   // In USDT smallest units (6 decimals)
    pub base_apy_bps: u16,
    pub boost_apy_bps: u16,
    pub total_apy_bps: u16,
    pub lock_period_months: u8,
    pub payout_frequency: u8,       // 1=monthly, 3=quarterly, 12=yearly

    /// Boost details
    pub boost_token_mint: Pubkey,
    pub boost_token_amount: u64,
    pub boost_locked: bool,

    /// Timestamps
    pub created_at: i64,
    pub lock_start_at: i64,
    pub lock_end_at: i64,

    /// Claim tracking
    pub total_takara_claimed: u64,
    pub last_takara_claim_at: i64,
    pub claim_nonce: u64,

    /// Status
    pub is_redeemed: bool,
    pub redeemed_at: i64,
}

impl WexelState {
    pub const LEN: usize = 8 +  // discriminator
        1 +                     // bump
        32 +                    // wexel_mint
        32 +                    // original_depositor
        8 +                     // deposit_id
        1 +                     // vault_type
        8 +                     // deposit_amount_usdt
        2 +                     // base_apy_bps
        2 +                     // boost_apy_bps
        2 +                     // total_apy_bps
        1 +                     // lock_period_months
        1 +                     // payout_frequency
        32 +                    // boost_token_mint
        8 +                     // boost_token_amount
        1 +                     // boost_locked
        8 +                     // created_at
        8 +                     // lock_start_at
        8 +                     // lock_end_at
        8 +                     // total_takara_claimed
        8 +                     // last_takara_claim_at
        8 +                     // claim_nonce
        1 +                     // is_redeemed
        8;                      // redeemed_at
}
```

### 7.4 Mint Wexel Instruction

```rust
// programs/takara/src/instructions/mint_wexel.rs

use anchor_lang::prelude::*;
use anchor_spl::token::{Mint, Token, TokenAccount};
use anchor_spl::associated_token::AssociatedToken;
use mpl_token_metadata::instructions as mpl_instructions;

use crate::state::{ProgramConfig, WexelState};
use crate::errors::TakaraError;
use crate::events::WexelMinted;

#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub struct WexelMintData {
    pub deposit_id: u64,
    pub vault_type: u8,
    pub deposit_amount_usdt: u64,
    pub tron_tx_hash: [u8; 32],
    pub base_apy_bps: u16,
    pub boost_apy_bps: u16,
    pub lock_period_months: u8,
    pub payout_frequency: u8,
    pub boost_token_mint: Pubkey,
    pub boost_token_amount: u64,
}

#[derive(Accounts)]
#[instruction(mint_data: WexelMintData)]
pub struct MintWexel<'info> {
    #[account(mut)]
    pub user: Signer<'info>,

    #[account(
        seeds = [b"config"],
        bump = config.bump,
    )]
    pub config: Account<'info, ProgramConfig>,

    /// CHECK: Backend signer - verified against config
    pub backend_signer: AccountInfo<'info>,

    /// New NFT mint (created in this instruction)
    #[account(
        init,
        payer = user,
        mint::decimals = 0,
        mint::authority = wexel_mint_authority,
        mint::freeze_authority = wexel_mint_authority,
    )]
    pub wexel_mint: Account<'info, Mint>,

    /// PDA that owns the mint
    /// CHECK: Seeds verified
    #[account(
        seeds = [b"mint_authority"],
        bump,
    )]
    pub wexel_mint_authority: AccountInfo<'info>,

    /// User's token account for the NFT
    #[account(
        init,
        payer = user,
        associated_token::mint = wexel_mint,
        associated_token::authority = user,
    )]
    pub user_wexel_account: Account<'info, TokenAccount>,

    /// Wexel state PDA
    #[account(
        init,
        payer = user,
        space = WexelState::LEN,
        seeds = [b"wexel_state", wexel_mint.key().as_ref()],
        bump,
    )]
    pub wexel_state: Account<'info, WexelState>,

    /// CHECK: Metaplex metadata account
    #[account(mut)]
    pub metadata_account: AccountInfo<'info>,

    /// CHECK: Collection NFT for verification
    pub collection_mint: AccountInfo<'info>,

    /// CHECK: Collection metadata
    #[account(mut)]
    pub collection_metadata: AccountInfo<'info>,

    /// CHECK: Collection master edition
    pub collection_master_edition: AccountInfo<'info>,

    /// Programs
    pub token_program: Program<'info, Token>,
    pub associated_token_program: Program<'info, AssociatedToken>,
    pub system_program: Program<'info, System>,
    pub rent: Sysvar<'info, Rent>,

    /// CHECK: Metaplex Token Metadata program
    pub metadata_program: AccountInfo<'info>,
}

pub fn handler(
    ctx: Context<MintWexel>,
    mint_data: WexelMintData,
    backend_signature: [u8; 64],
) -> Result<()> {
    let config = &ctx.accounts.config;

    // =========================================================================
    // SECURITY CHECK 1: Verify backend signer
    // =========================================================================
    require!(
        ctx.accounts.backend_signer.key() == config.backend_pubkey,
        TakaraError::InvalidBackendSigner
    );

    // =========================================================================
    // SECURITY CHECK 2: Verify backend signature over mint_data
    // =========================================================================
    let mint_data_bytes = mint_data.try_to_vec()?;
    let signature = ed25519_dalek::Signature::from_bytes(&backend_signature)
        .map_err(|_| TakaraError::InvalidSignature)?;
    let pubkey = ed25519_dalek::PublicKey::from_bytes(
        &config.backend_pubkey.to_bytes()
    ).map_err(|_| TakaraError::InvalidBackendSigner)?;

    pubkey.verify_strict(&mint_data_bytes, &signature)
        .map_err(|_| TakaraError::InvalidSignature)?;

    // =========================================================================
    // SECURITY CHECK 3: Verify collection
    // =========================================================================
    require!(
        ctx.accounts.collection_mint.key() == config.wexel_collection,
        TakaraError::InvalidCollection
    );

    // =========================================================================
    // Mint NFT to user
    // =========================================================================
    let mint_authority_bump = ctx.bumps.wexel_mint_authority;
    let mint_authority_seeds = &[b"mint_authority".as_ref(), &[mint_authority_bump]];
    let signer_seeds = &[&mint_authority_seeds[..]];

    // Mint 1 token to user
    anchor_spl::token::mint_to(
        CpiContext::new_with_signer(
            ctx.accounts.token_program.to_account_info(),
            anchor_spl::token::MintTo {
                mint: ctx.accounts.wexel_mint.to_account_info(),
                to: ctx.accounts.user_wexel_account.to_account_info(),
                authority: ctx.accounts.wexel_mint_authority.to_account_info(),
            },
            signer_seeds,
        ),
        1,
    )?;

    // =========================================================================
    // Create metadata (using Metaplex)
    // =========================================================================
    // ... Metaplex CPI calls for creating metadata and verifying collection

    // =========================================================================
    // Initialize Wexel State PDA
    // =========================================================================
    let wexel_state = &mut ctx.accounts.wexel_state;
    let clock = Clock::get()?;

    wexel_state.bump = ctx.bumps.wexel_state;
    wexel_state.wexel_mint = ctx.accounts.wexel_mint.key();
    wexel_state.original_depositor = ctx.accounts.user.key();
    wexel_state.deposit_id = mint_data.deposit_id;
    wexel_state.vault_type = mint_data.vault_type;
    wexel_state.deposit_amount_usdt = mint_data.deposit_amount_usdt;
    wexel_state.base_apy_bps = mint_data.base_apy_bps;
    wexel_state.boost_apy_bps = mint_data.boost_apy_bps;
    wexel_state.total_apy_bps = mint_data.base_apy_bps + mint_data.boost_apy_bps;
    wexel_state.lock_period_months = mint_data.lock_period_months;
    wexel_state.payout_frequency = mint_data.payout_frequency;
    wexel_state.boost_token_mint = mint_data.boost_token_mint;
    wexel_state.boost_token_amount = mint_data.boost_token_amount;
    wexel_state.boost_locked = mint_data.boost_token_amount > 0;
    wexel_state.created_at = clock.unix_timestamp;
    wexel_state.lock_start_at = clock.unix_timestamp;

    // Calculate lock end timestamp
    let seconds_per_month: i64 = 30 * 24 * 60 * 60;
    wexel_state.lock_end_at = clock.unix_timestamp +
        (mint_data.lock_period_months as i64 * seconds_per_month);

    wexel_state.total_takara_claimed = 0;
    wexel_state.last_takara_claim_at = 0;
    wexel_state.claim_nonce = 0;
    wexel_state.is_redeemed = false;
    wexel_state.redeemed_at = 0;

    // =========================================================================
    // Emit event
    // =========================================================================
    emit!(WexelMinted {
        wexel_mint: ctx.accounts.wexel_mint.key(),
        owner: ctx.accounts.user.key(),
        deposit_id: mint_data.deposit_id,
        vault_type: mint_data.vault_type,
        deposit_amount_usdt: mint_data.deposit_amount_usdt,
        total_apy_bps: wexel_state.total_apy_bps,
        lock_end_at: wexel_state.lock_end_at,
    });

    Ok(())
}
```

### 7.5 Claim Takara Instruction (Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¾Ğ¹ Ğ²Ğ»Ğ°Ğ´ĞµĞ½Ğ¸Ñ)

```rust
// programs/takara/src/instructions/claim_takara.rs

use anchor_lang::prelude::*;
use anchor_spl::token::{self, Mint, Token, TokenAccount};
use anchor_spl::associated_token::AssociatedToken;

use crate::state::{ProgramConfig, WexelState};
use crate::errors::TakaraError;
use crate::events::TakaraClaimed;

#[derive(Accounts)]
pub struct ClaimTakara<'info> {
    #[account(mut)]
    pub claimer: Signer<'info>,

    #[account(
        seeds = [b"config"],
        bump = config.bump,
    )]
    pub config: Account<'info, ProgramConfig>,

    /// Wexel NFT mint
    pub wexel_mint: Account<'info, Mint>,

    /// Claimer's token account holding the Wexel NFT
    /// THIS IS THE CRITICAL OWNERSHIP CHECK!
    #[account(
        constraint = claimer_wexel_account.mint == wexel_mint.key() @ TakaraError::InvalidMint,
        constraint = claimer_wexel_account.owner == claimer.key() @ TakaraError::NotWexelOwner,
        constraint = claimer_wexel_account.amount == 1 @ TakaraError::NotWexelOwner,
    )]
    pub claimer_wexel_account: Account<'info, TokenAccount>,

    /// Wexel state PDA
    #[account(
        mut,
        seeds = [b"wexel_state", wexel_mint.key().as_ref()],
        bump = wexel_state.bump,
        constraint = !wexel_state.is_redeemed @ TakaraError::AlreadyRedeemed,
    )]
    pub wexel_state: Account<'info, WexelState>,

    /// Takara token mint
    #[account(
        mut,
        constraint = takara_mint.key() == config.takara_mint @ TakaraError::InvalidMint,
    )]
    pub takara_mint: Account<'info, Mint>,

    /// Program's Takara mint authority (PDA)
    /// CHECK: Seeds verified
    #[account(
        seeds = [b"takara_authority"],
        bump,
    )]
    pub takara_authority: AccountInfo<'info>,

    /// Claimer's Takara token account
    #[account(
        init_if_needed,
        payer = claimer,
        associated_token::mint = takara_mint,
        associated_token::authority = claimer,
    )]
    pub claimer_takara_account: Account<'info, TokenAccount>,

    /// CHECK: Backend signer for claim authorization
    pub backend_signer: AccountInfo<'info>,

    pub token_program: Program<'info, Token>,
    pub associated_token_program: Program<'info, AssociatedToken>,
    pub system_program: Program<'info, System>,
}

pub fn handler(
    ctx: Context<ClaimTakara>,
    amount: u64,
    nonce: u64,
    timestamp: i64,
    backend_signature: [u8; 64],
) -> Result<()> {
    let config = &ctx.accounts.config;
    let wexel_state = &mut ctx.accounts.wexel_state;
    let clock = Clock::get()?;

    // =========================================================================
    // SECURITY CHECK 1: Verify claimer owns the Wexel NFT
    // This is enforced by account constraints above:
    // - claimer_wexel_account.owner == claimer.key()
    // - claimer_wexel_account.amount == 1
    // =========================================================================

    // =========================================================================
    // SECURITY CHECK 2: Verify nonce (anti-replay)
    // =========================================================================
    require!(
        nonce > wexel_state.claim_nonce,
        TakaraError::NonceAlreadyUsed
    );

    // =========================================================================
    // SECURITY CHECK 3: Verify timestamp freshness (5 minutes)
    // =========================================================================
    let max_age: i64 = 5 * 60; // 5 minutes
    require!(
        clock.unix_timestamp - timestamp <= max_age,
        TakaraError::SignatureExpired
    );

    // =========================================================================
    // SECURITY CHECK 4: Verify backend signature
    // =========================================================================
    require!(
        ctx.accounts.backend_signer.key() == config.backend_pubkey,
        TakaraError::InvalidBackendSigner
    );

    // Construct message that backend signed
    let message = format!(
        "claim_takara:{}:{}:{}:{}",
        wexel_state.wexel_mint,
        amount,
        nonce,
        timestamp
    );

    let signature = ed25519_dalek::Signature::from_bytes(&backend_signature)
        .map_err(|_| TakaraError::InvalidSignature)?;
    let pubkey = ed25519_dalek::PublicKey::from_bytes(
        &config.backend_pubkey.to_bytes()
    ).map_err(|_| TakaraError::InvalidBackendSigner)?;

    pubkey.verify_strict(message.as_bytes(), &signature)
        .map_err(|_| TakaraError::InvalidSignature)?;

    // =========================================================================
    // SECURITY CHECK 5: For Vault 1, verify claim interval (7 days)
    // =========================================================================
    if wexel_state.vault_type == 1 {
        let min_interval: i64 = 7 * 24 * 60 * 60; // 7 days in seconds
        if wexel_state.last_takara_claim_at > 0 {
            require!(
                clock.unix_timestamp - wexel_state.last_takara_claim_at >= min_interval,
                TakaraError::ClaimTooSoon
            );
        }
    }

    // =========================================================================
    // Mint Takara tokens to claimer
    // =========================================================================
    let authority_bump = ctx.bumps.takara_authority;
    let authority_seeds = &[b"takara_authority".as_ref(), &[authority_bump]];
    let signer_seeds = &[&authority_seeds[..]];

    token::mint_to(
        CpiContext::new_with_signer(
            ctx.accounts.token_program.to_account_info(),
            token::MintTo {
                mint: ctx.accounts.takara_mint.to_account_info(),
                to: ctx.accounts.claimer_takara_account.to_account_info(),
                authority: ctx.accounts.takara_authority.to_account_info(),
            },
            signer_seeds,
        ),
        amount,
    )?;

    // =========================================================================
    // Update state
    // =========================================================================
    wexel_state.claim_nonce = nonce;
    wexel_state.total_takara_claimed = wexel_state.total_takara_claimed
        .checked_add(amount)
        .ok_or(TakaraError::MathOverflow)?;
    wexel_state.last_takara_claim_at = clock.unix_timestamp;

    // =========================================================================
    // Emit event
    // =========================================================================
    emit!(TakaraClaimed {
        wexel_mint: wexel_state.wexel_mint,
        claimer: ctx.accounts.claimer.key(),
        amount,
        total_claimed: wexel_state.total_takara_claimed,
        nonce,
    });

    Ok(())
}
```

---

## âœ… Ğ§ĞĞ¡Ğ¢Ğ¬ 8: CHECKLIST Ğ”Ğ›Ğ¯ ĞĞ“Ğ•ĞĞ¢Ğ

### 8.1 Database Tasks

- [ ] ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ schema.prisma ÑĞ¾Ğ³Ğ»Ğ°ÑĞ½Ğ¾ Ğ§ĞĞ¡Ğ¢Ğ˜ 4
- [ ] Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ¼Ğ¸Ğ³Ñ€Ğ°Ñ†Ğ¸Ñ: `npx prisma migrate dev --name vault_refactor_v6`
- [ ] ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ seed data Ñ ĞŸĞ ĞĞ’Ğ˜Ğ›Ğ¬ĞĞ«ĞœĞ˜ APY
- [ ] Ğ—Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ seed: `npx prisma db seed`
- [ ] ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ Ğ² Ğ‘Ğ”:
  - [ ] Vault 2: baseApyBps = 700, boostApyBps = 600, maxApyBps = 1300
  - [ ] Vault 3: baseApyBps = 800, boostApyBps = 700, maxApyBps = 1500

### 8.2 Backend Tasks

- [ ] ĞŸĞµÑ€ĞµĞ¸Ğ¼ĞµĞ½Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ²ÑĞµ "Pool" â†’ "Vault" Ğ² ĞºĞ¾Ğ´Ğµ
- [ ] Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ DepositFlowService Ñ Ğ¼ÑƒĞ»ÑŒÑ‚Ğ¸-Ñ‡ĞµĞ¹Ğ½ Ğ»Ğ¾Ğ³Ğ¸ĞºĞ¾Ğ¹
- [ ] Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ WexelVerificationService
- [ ] Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ YieldCalculatorService Ñ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ñ‹Ğ¼Ğ¸ Ñ„Ğ¾Ñ€Ğ¼ÑƒĞ»Ğ°Ğ¼Ğ¸
- [ ] Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ TronService Ğ´Ğ»Ñ Ğ²ĞµÑ€Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ğ¸ USDT Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ğ¸Ğ¹
- [ ] Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ SolanaService Ğ´Ğ»Ñ Ğ²Ğ·Ğ°Ğ¸Ğ¼Ğ¾Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ñ Ñ Ğ¿Ñ€Ğ¾Ğ³Ñ€Ğ°Ğ¼Ğ¼Ğ¾Ğ¹
- [ ] Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ endpoint: POST /deposits/initialize
- [ ] Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ endpoint: POST /deposits/:id/confirm-tron
- [ ] Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ endpoint: POST /deposits/:id/confirm-boost
- [ ] Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ endpoint: POST /deposits/:id/mint-signature
- [ ] Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ endpoint: POST /deposits/:id/confirm-mint
- [ ] Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ endpoint: POST /claims/:depositId/takara
- [ ] Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ endpoint: POST /claims/:depositId/usdt
- [ ] Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ guards Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸ Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑĞµĞ¹

### 8.3 Frontend Tasks

- [ ] Ğ—Ğ°Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ²ÑĞµ "Pool" â†’ "Vault" Ğ² UI
- [ ] Ğ—Ğ°Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ²ÑĞµ "TUSD" â†’ "TAKARA" Ğ² UI
- [ ] ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ VaultCard Ñ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ñ‹Ğ¼Ğ¸ APY
- [ ] Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ DepositWizard ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚ (5 ÑˆĞ°Ğ³Ğ¾Ğ²)
- [ ] Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ Ğ´Ğ²ÑƒÑ… ĞºĞ¾ÑˆĞµĞ»ÑŒĞºĞ¾Ğ² (Tron + Solana)
- [ ] Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ USDT deposit step (TronLink)
- [ ] Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Boost lock step (Phantom/Solflare)
- [ ] Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Wexel mint step
- [ ] ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Dashboard Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ñ Ğ´ĞµĞ¿Ğ¾Ğ·Ğ¸Ñ‚Ğ¾Ğ² Ğ¿Ğ¾ NFT
- [ ] Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Claim UI Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¾Ğ¹ ownership

### 8.4 Smart Contract Tasks

- [ ] Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Anchor Ğ¿Ñ€Ğ¾ĞµĞºÑ‚ Ğ² /programs/takara
- [ ] Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ ProgramConfig state
- [ ] Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ WexelState PDA
- [ ] Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ lock_boost instruction
- [ ] Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ mint_wexel instruction
- [ ] Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ claim_takara instruction
- [ ] Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ redeem_wexel instruction
- [ ] Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ²ÑĞµ security checks ÑĞ¾Ğ³Ğ»Ğ°ÑĞ½Ğ¾ Ğ§ĞĞ¡Ğ¢Ğ˜ 7
- [ ] ĞĞ°Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒ Ñ‚ĞµÑÑ‚Ñ‹ Ğ´Ğ»Ñ Ğ²ÑĞµÑ… instructions
- [ ] Deploy Ğ½Ğ° devnet Ğ´Ğ»Ñ Ñ‚ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ
- [ ] ĞŸÑ€Ğ¾Ğ²ĞµÑÑ‚Ğ¸ security audit

### 8.5 Security Verification

- [ ] Backend signature verification Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚
- [ ] NFT ownership check Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚
- [ ] Nonce anti-replay Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚
- [ ] Timestamp validation Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚
- [ ] Collection verification Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚
- [ ] ĞĞµĞ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ¿Ğ¾Ğ´Ğ´ĞµĞ»Ğ°Ñ‚ÑŒ Wexel NFT
- [ ] ĞĞµĞ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ claim Ğ±ĞµĞ· ownership

---

## ğŸš¨ ĞšĞ Ğ˜Ğ¢Ğ˜Ğ§Ğ•Ğ¡ĞšĞ˜Ğ• ĞĞĞŸĞĞœĞ˜ĞĞĞĞ˜Ğ¯

1. **APY VALUES ARE FINAL:**
   - Vault 2: 7% base + 6% boost = 13% max
   - Vault 3: 8% base + 7% boost = 15% max

2. **WEXEL = OWNERSHIP:**
   - ĞšÑ‚Ğ¾ Ğ²Ğ»Ğ°Ğ´ĞµĞµÑ‚ NFT = ĞºÑ‚Ğ¾ Ğ²Ğ»Ğ°Ğ´ĞµĞµÑ‚ Ğ´ĞµĞ¿Ğ¾Ğ·Ğ¸Ñ‚Ğ¾Ğ¼
   - ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° ownership ĞĞ‘Ğ¯Ğ—ĞĞ¢Ğ•Ğ›Ğ¬ĞĞ Ğ´Ğ»Ñ ĞºĞ°Ğ¶Ğ´Ğ¾Ğ³Ğ¾ claim

3. **MULTI-CHAIN FLOW:**
   - Step 1: USDT Ğ½Ğ° Tron (TronLink)
   - Step 2: Boost Ğ½Ğ° Solana (Phantom)
   - Step 3: Mint NFT Ğ½Ğ° Solana (Phantom)

4. **SECURITY FIRST:**
   - Ğ’ÑĞµ claims Ñ‚Ñ€ĞµĞ±ÑƒÑÑ‚ backend signature
   - Ğ’ÑĞµ claims Ñ‚Ñ€ĞµĞ±ÑƒÑÑ‚ ownership verification
   - Ğ’ÑĞµ claims Ñ‚Ñ€ĞµĞ±ÑƒÑÑ‚ nonce validation

---

**END OF MASTER PROMPT v6**
